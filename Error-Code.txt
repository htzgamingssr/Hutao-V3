local Fluent = loadstring(game:HttpGet("https://raw.githubusercontent.com/htzgamingssr/Hutao-V3/refs/heads/main/UI-Hutao-Hub-V3.txt"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()

local Window = Fluent:CreateWindow({
    Title = "Hutao Hub (V3) [Premium] | Forsaken |",
    SubTitle = "Version 5.4.8",
    Search = true,
    Icon = "rbxassetid://111221806665390",
    TabWidth = 160,
    Size = UDim2.fromOffset(480, 360),
    Acrylic = true,
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.RightAlt,

    UserInfo = false,
    UserInfoTop = false,
    UserInfoTitle = game:GetService("Players").LocalPlayer.DisplayName,
    UserInfoSubtitle = "SLK Äáº¹p Trai",
    UserInfoSubtitleColor = Color3.fromRGB(71, 123, 255)
})

local Tabs = {
    Dev = Window:AddTab({ Title = "About", Icon = "info" }),
    Farm = Window:AddTab({ Title = "Farm", Icon = "box" }),
    Main = Window:AddTab({ Title = "Main", Icon = "home" }),
    Event = Window:AddTab({ Title = "Event", Icon = "bell" }),
    Custom = Window:AddTab({ Title = "Custom", Icon = "brush" }),
    Player = Window:AddTab({ Title = "Player", Icon = "user" }),
    Visual = Window:AddTab({ Title = "Visual", Icon = "eye" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "menu" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" }),
}

-- Pháº§n Logic ChÃ­nh

loadstring(game:HttpGet("https://raw.githubusercontent.com/htzgamingssr/Hutao-V3/refs/heads/main/LogicManager.txt"))()

local RunService = game:GetService("RunService")
local Camera = workspace.CurrentCamera

local ESPManager = {
    ActiveTypes = {},
    Objects = {},
    Filters = {},
    Colors = {},
    Watchers = {},
    ShowHP = {},
    _pendingCreate = {},
}

local function getPrimaryPart(model)
    if not model then return nil end
    local p = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
    return p
end

function ESPManager:RegisterType(name, color, filterFn, showHP)
    self.Filters[name] = filterFn
    self.Colors[name] = color
    self.ShowHP[name] = showHP or false
    self.ActiveTypes[name] = false
end

local function disconnectConns(tbl)
    if not tbl then return end
    for _, c in pairs(tbl) do
        if c and typeof(c.Disconnect) == "function" then
            pcall(function() c:Disconnect() end)
        end
    end
end

function ESPManager:_CreateImmediate(model, typeName)
    if not model or not model.Parent then return end
    if ESPManager.Objects[model] then
        local existing = ESPManager.Objects[model]
        if existing.gui and existing.gui.Parent and existing.hl and existing.hl.Parent then
            return
        else
            ESPManager:Remove(model)
        end
    end

    local color = ESPManager.Colors[typeName]
    local part = getPrimaryPart(model)
    if not part then return end

    local billboard = Instance.new("BillboardGui")
    billboard.Name = "ESP_" .. typeName
    billboard.Size = UDim2.new(0, 180, 0, 35)
    billboard.AlwaysOnTop = true
    billboard.StudsOffset = Vector3.new(0, 3, 0)
    billboard.MaxDistance = 600
    billboard.Parent = part

    local label = Instance.new("TextLabel")
    label.Size = UDim2.new(1, 0, 1, 0)
    label.BackgroundTransparency = 1
    label.TextColor3 = color
    label.TextStrokeTransparency = 0.3
    label.Font = Enum.Font.GothamBold
    label.TextSize = 16
    label.Text = model.Name
    label.Parent = billboard

    local hl = Instance.new("Highlight")
    hl.Adornee = model
    hl.FillColor = color
    hl.OutlineColor = color
    hl.FillTransparency = 0.7
    hl.OutlineTransparency = 0
    hl.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
    hl.Enabled = true
    hl.Parent = model

    local conns = {}

    table.insert(conns, model.AncestryChanged:Connect(function(_, parent)
        if not model:IsDescendantOf(workspace) then
            if ESPManager.Objects[model] and ESPManager.Objects[model].type == typeName then
                ESPManager:Remove(model)
            end
            return
        end
        if ESPManager.ActiveTypes[typeName] and ESPManager.Filters[typeName](model) then
            ESPManager:_ScheduleCreate(model, typeName)
        end
    end))

    local function watchHumanoid(hum)
        if not hum then return end
        table.insert(conns, hum.Died:Connect(function()
            if ESPManager.Objects[model] and ESPManager.Objects[model].type == typeName then
                ESPManager:Remove(model)
            end
        end))
    end

    watchHumanoid(model:FindFirstChildOfClass("Humanoid"))

    table.insert(conns, model.ChildAdded:Connect(function(child)
        if child and child:IsA("Humanoid") then
            watchHumanoid(child)
            if ESPManager.ActiveTypes[typeName] and ESPManager.Filters[typeName](model) then
                ESPManager:_ScheduleCreate(model, typeName)
            end
        end
        if (child:IsA("BasePart") or child:IsA("Model")) and ESPManager.ActiveTypes[typeName] and ESPManager.Filters[typeName](model) then
            ESPManager:_ScheduleCreate(model, typeName)
        end
    end))

    ESPManager.Objects[model] = {
        type = typeName,
        gui = billboard,
        label = label,
        hl = hl,
        conns = conns,
    }
end

function ESPManager:_ScheduleCreate(model, typeName)
    if not model or not typeName then return end
    if not ESPManager.ActiveTypes[typeName] then return end
    if ESPManager._pendingCreate[model] then return end
    ESPManager._pendingCreate[model] = true

    task.delay(0.5, function()
        pcall(function()
            ESPManager._pendingCreate[model] = nil
            if not model or not model.Parent then return end
            local filterFn = ESPManager.Filters[typeName]
            if not filterFn or not filterFn(model) then return end
            ESPManager:_CreateImmediate(model, typeName)
        end)
    end)
end

function ESPManager:Remove(model)
    local data = self.Objects[model]
    if not data then return end

    if data.conns then
        disconnectConns(data.conns)
    end

    pcall(function() if data.gui then data.gui:Destroy() end end)
    pcall(function() if data.hl then data.hl:Destroy() end end)
    self.Objects[model] = nil
    self._pendingCreate[model] = nil
end

function ESPManager:StartWatcher(typeName)
    local filterFn = self.Filters[typeName]
    if not filterFn then return end
    if self.Watchers[typeName] then return end

    for _, obj in ipairs(workspace:GetDescendants()) do
        if filterFn(obj) then
            self:_ScheduleCreate(obj, typeName)
        end
    end

    local addConn = workspace.DescendantAdded:Connect(function(obj)
        if self.ActiveTypes[typeName] and filterFn(obj) then
            self:_ScheduleCreate(obj, typeName)
        end
    end)

    local removeConn = workspace.DescendantRemoving:Connect(function(obj)
        if self.Objects[obj] and self.Objects[obj].type == typeName then
            self:Remove(obj)
        end
        self._pendingCreate[obj] = nil
    end)

    self.Watchers[typeName] = {add = addConn, rem = removeConn}
end

function ESPManager:StopWatcher(typeName)
    local w = self.Watchers[typeName]
    if w then
        if w.add then w.add:Disconnect() end
        if w.rem then w.rem:Disconnect() end
    end
    self.Watchers[typeName] = nil
end

RunService.Heartbeat:Connect(function()
    for model, data in pairs(ESPManager.Objects) do
        if not model or not model.Parent then
            ESPManager:Remove(model)
        else
            local part = getPrimaryPart(model)
            if not part then
                ESPManager:Remove(model)
            else
                local needRecreate = false
                if (not data.gui) or (not data.hl) or (not data.label) then
                    needRecreate = true
                else
                    if not data.gui.Parent then
                        needRecreate = true
                    end
                end
                if needRecreate then
                    local typeName = data.type
                    ESPManager:Remove(model)
                    ESPManager:_ScheduleCreate(model, typeName)
                else
                    local dist = (Camera.CFrame.Position - part.Position).Magnitude
                    local txt = model.Name
                    local showHP = ESPManager.ShowHP[data.type]
                    if showHP then
                        local hum = model:FindFirstChildOfClass("Humanoid")
                        if hum then
                            txt = string.format("%s | HP:%d | [%.0fm]", txt, math.floor(hum.Health), dist)
                        else
                            txt = string.format("%s [%.0fm]", txt, dist)
                        end
                    else
                        txt = string.format("%s [%.0fm]", txt, dist)
                    end
                    if data.label then
                        pcall(function() data.label.Text = txt end)
                    end
                end
            end
        end
    end
end)

function ESPManager:SetEnabled(typeName, state)
    self.ActiveTypes[typeName] = state

    if state then
        self:StartWatcher(typeName)
        local filterFn = self.Filters[typeName]
        if filterFn then
            for _, obj in ipairs(workspace:GetDescendants()) do
                if filterFn(obj) then
                    self:_ScheduleCreate(obj, typeName)
                end
            end
        end
    else
        self:StopWatcher(typeName)
        for model, data in pairs(self.Objects) do
            if data.type == typeName then
                self:Remove(model)
            end
        end
    end
end

_G.ESPManager = ESPManager




local UserInputService = game:GetService("UserInputService")
local CoreGui = game:GetService("CoreGui")
local TweenService = game:GetService("TweenService")

local ExistingUI = CoreGui:FindFirstChild("HutaoHubMinimizeUI")
if ExistingUI then
    ExistingUI:Destroy()
end

local DragUI = Instance.new("ScreenGui")
DragUI.Name = "HutaoHubMinimizeUI"
DragUI.ResetOnSpawn = false
DragUI.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
DragUI.Parent = CoreGui

local Button = Instance.new("ImageButton")
Button.Parent = DragUI
Button.Size = UDim2.new(0, 50, 0, 50)
Button.Position = UDim2.new(0, 10, 1, -85)
Button.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
Button.BackgroundTransparency = 0.3
Button.BorderSizePixel = 0
Button.ClipsDescendants = true
Button.Image = "rbxassetid://78916242543205" -- Thay icon náº¿u muá»‘n
Button.ScaleType = Enum.ScaleType.Fit
Button.Active = true
Button.ZIndex = 1000

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(1, 0)
UICorner.Parent = Button

local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out)

local function ToggleUI()
    if Window.Minimized then
        Window:Minimize(false)
    else
        Window:Minimize(true)
    end
end

local isDragging = false
local dragThreshold = 10

Button.MouseButton1Click:Connect(function()
    if isDragging then return end

    TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.5,
        Size = UDim2.new(0, 45, 0, 45),
        Rotation = 5
    }):Play()
    task.wait(0.1)
    TweenService:Create(Button, tweenInfo, {
        BackgroundTransparency = 0.3,
        Size = UDim2.new(0, 50, 0, 50),
        Rotation = 0
    }):Play()

    ToggleUI()
end)

Button.MouseEnter:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 55, 0, 55)}):Play()
end)

Button.MouseLeave:Connect(function()
    TweenService:Create(Button, tweenInfo, {Size = UDim2.new(0, 50, 0, 50)}):Play()
end)

local dragging, dragStart, startPos

local function StartDrag(input)
    isDragging = false
    dragging = true
    dragStart = input.Position
    startPos = Button.Position

    input.Changed:Connect(function()
        if input.UserInputState == Enum.UserInputState.End then
            dragging = false
        end
    end)
end

local function OnDrag(input)
    if dragging then
        local delta = (input.Position - dragStart).Magnitude
        if delta > dragThreshold then
            isDragging = true
        end
        Button.Position = UDim2.new(
            startPos.X.Scale,
            startPos.X.Offset + (input.Position.X - dragStart.X),
            startPos.Y.Scale,
            startPos.Y.Offset + (input.Position.Y - dragStart.Y)
        )
    end
end

Button.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
        StartDrag(input)
    end
end)

Button.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
        OnDrag(input)
    end
end)  


-- Tab.Dev

local Options = Fluent.Options


    Tabs.Dev:AddParagraph({
        Title = "Note",
        Content = "Thank you for using the script!"
    })

    Tabs.Dev:AddSection("â†³ Links")

    Tabs.Dev:AddButton({
        Title = "Discord",
        Description = "Copy the link to join the discord!",
        Callback = function()
            setclipboard("https://discord.gg/WEGT92yv")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard",
                SubContent = "",
                Duration = 3 
            })
        end
    })



    Tabs.Dev:AddButton({
        Title = "Youtube",
        Description = "Copy link to Subscribe to Youtube channel!",
        Callback = function()
            setclipboard("https://www.youtube.com/@SLKgamingSSR")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "",
                Duration = 3 
            })
        end
    })


    Tabs.Dev:AddButton({
        Title = "Facebook",
        Description = "Copy link to join facebook group!",
        Callback = function()
            setclipboard("https://www.facebook.com/groups/1180845463307087/?ref=share&mibextid=NSMWBT")
            Fluent:Notify({
                Title = "Notification",
                Content = "Successfully copied to the clipboard!",
                SubContent = "",
                Duration = 3 
            })
        end
    })

-- Tabs.Farm

do
    local Players = game:GetService("Players")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local LocalPlayer = Players.LocalPlayer

    local Active = false
    local loopRunning = false
    local CurrentTarget = nil
    local lastAttack = 0

    local KillersList = {
        ["Slasher"] = true,
        ["1x1x1x1"] = true,
        ["c00lkidd"] = true,
        ["Noli"] = true,
        ["JohnDoe"] = true,
        ["Guest 666"] = true,
        ["Sixer"] = true,
    }

    local PriorityList = {
        ["0206octavio"] = true
    }

    local SkillList = {
        "Slash", "Stab", "Punch",
        "VoidRush", "Nova",
        "CorruptEnergy", "Behead", "GashingWound",
        "MassInfection", "CorruptNature", "WalkspeedOverride", "PizzaDelivery",
        "UnstableEye", "Entanglement",
        "DigitalFootprint", "404Error",
        "RagingPace", "Carving Slash", "Demonic Pursuit",
        "Infernal Cry", "Blood Rush"
    }

    local SkillRemotes = {}

    local function findSkillRemoteFromButton(button)
        for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        return v
                    end
                end
            end
        end
        return nil
    end

    local function initSkillButtons()
        local gui = LocalPlayer:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        if not container then return end

        for _, child in ipairs(container:GetChildren()) do
            if child:IsA("ImageButton") then
                local remote = findSkillRemoteFromButton(child)
                if remote then
                    SkillRemotes[child.Name] = remote
                    warn("[Skill] Found RemoteEvent for:", child.Name, remote:GetFullName())
                end
            end
        end
    end

    initSkillButtons()
    LocalPlayer.CharacterAdded:Connect(function()
        task.wait(1)
        initSkillButtons()
    end)

    local function GetPriorityTarget()
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") then
                if PriorityList[survivor.Name] then
                    local humanoid = survivor:FindFirstChildOfClass("Humanoid")
                    if humanoid and humanoid.Health > 0 then
                        return survivor
                    end
                end
            end
        end
        return nil
    end

    local function GetClosestSurvivor()
        local priorityTarget = GetPriorityTarget()
        if priorityTarget then return priorityTarget end

        local localChar = LocalPlayer.Character
        if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return nil end
        local survivorsFolder = workspace:FindFirstChild("Players") and workspace.Players:FindFirstChild("Survivors")
        if not survivorsFolder then return nil end

        local closest, minDist = nil, math.huge
        for _, survivor in ipairs(survivorsFolder:GetChildren()) do
            local humanoid = survivor:FindFirstChildOfClass("Humanoid")
            if survivor:IsA("Model") and survivor:FindFirstChild("HumanoidRootPart") and humanoid and humanoid.Health > 0 then
                local dist = (localChar.HumanoidRootPart.Position - survivor.HumanoidRootPart.Position).Magnitude
                if dist < minDist then
                    minDist = dist
                    closest = survivor
                end
            end
        end
        return closest
    end

    local function KillTarget(target)
        pcall(function()
            if not target then return end
            local localChar = LocalPlayer.Character
            if not (localChar and localChar:FindFirstChild("HumanoidRootPart")) then return end

            local root = localChar.HumanoidRootPart
            local targetRoot = target:FindFirstChild("HumanoidRootPart")
            if not targetRoot then return end

            if tick() - lastAttack >= 0.05 then
                lastAttack = tick()

                for _, skillName in ipairs(SkillList) do
                    local offset = targetRoot.CFrame.LookVector * -2
                    root.CFrame = targetRoot.CFrame + offset

                    local remote = SkillRemotes[skillName]
                    if remote then
                        remote:FireServer(true)
                        task.wait(0.005)
                        remote:FireServer(false)
                    else
                        local gui = LocalPlayer:FindFirstChild("PlayerGui")
                        local mainUI = gui and gui:FindFirstChild("MainUI")
                        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
                        if container then
                            local button = container:FindFirstChild(skillName)
                            if button and button:IsA("ImageButton") then
                                for _, conn in ipairs(getconnections(button.MouseButton1Click)) do
                                    if conn.Function then
                                        pcall(conn.Function)
                                    end
                                end
                                pcall(function() button:Activate() end)
                            end
                        end

                        local net = ReplicatedStorage:FindFirstChild("Modules")
                                    and ReplicatedStorage.Modules:FindFirstChild("Network")
                                    and ReplicatedStorage.Modules.Network:FindFirstChild("RemoteEvent")
                        if net and typeof(net.FireServer) == "function" then
                            net:FireServer("UseActorAbility", skillName)
                        end
                    end

                    task.wait(0.01)
                end
            end
        end)
    end

    local function StartLoop()
        if loopRunning then return end
        loopRunning = true
        task.spawn(function()
            while Active do
                local char = LocalPlayer.Character
                if not (char and KillersList[char.Name]) then
                    CurrentTarget = nil
                    task.wait(0.5)
                    continue
                end

                if not CurrentTarget 
                   or not CurrentTarget.Parent 
                   or not CurrentTarget:FindFirstChildOfClass("Humanoid") 
                   or CurrentTarget:FindFirstChildOfClass("Humanoid").Health <= 0 then
                    CurrentTarget = GetClosestSurvivor()
                end
                if CurrentTarget then
                    KillTarget(CurrentTarget)
                end
                task.wait(0.01)
            end
            loopRunning = false
        end)
    end

    Tabs.Farm:AddToggle("KillersFarmV2", {
        Title = "Killers Farm V2",
        Default = false,
        Callback = function(Value)
            Active = Value
            if Active then
                StartLoop()
            end
        end
    })
end




local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local solveGeneratorCooldown = false
local genDelay = 0.75 -- delay máº·c Ä‘á»‹nh
local currentCharacter
local Spectators = {}
local isInGame, Survivor = false, false

local DangerousKillers = {
    ["Slasher"] = true,
    ["1x1x1x1"] = true,
    ["c00lkidd"] = true,
    ["Noli"] = true,
    ["JohnDoe"] = true,
    ["Guest 666"] = true,
    ["Sixer"] = true
}

local function isKillerNearGenerator(generatorPos, distance)
    local killersFolder = workspace.Players:FindFirstChild("Killers")
    if not killersFolder then return false end
    for _, killer in ipairs(killersFolder:GetChildren()) do
        if killer:IsA("Model") and killer:FindFirstChild("HumanoidRootPart") then
            if DangerousKillers[killer.Name] then
                local dist = (killer.HumanoidRootPart.Position - generatorPos).Magnitude
                if dist <= distance then
                    return true
                end
            end
        end
    end
    return false
end

local function getUnfinishedGenerators()
    local list = {}
    local map = workspace:FindFirstChild("Map") 
        and workspace.Map:FindFirstChild("Ingame") 
        and workspace.Map.Ingame:FindFirstChild("Map")
    if map then
        for _, gen in ipairs(map:GetChildren()) do
            if gen.Name == "Generator" 
                and gen:FindFirstChild("Progress") 
                and gen.Progress.Value < 100 then
                table.insert(list, gen)
            end
        end
    end

    if #list == 1 then
        genDelay = 1.5
    else
        genDelay = 0.75
    end

    return list
end

local function fixOneGenerator(gen)
    if solveGeneratorCooldown then return end
    if not currentCharacter or not currentCharacter:FindFirstChild("HumanoidRootPart") then return end

    local genCFrame = gen:GetPivot()
    local goalPos = (genCFrame * CFrame.new(0, 0, -7)).Position

    if isKillerNearGenerator(goalPos, 50) then
        print("âš ï¸ Bá» qua generator vÃ¬ killer nguy hiá»ƒm gáº§n!")
        return
    end

    currentCharacter:PivotTo(CFrame.new(goalPos + Vector3.new(0, 0, 0))) -- chá»‰nh Ä‘á»™ cao, Ä‘á»™ lá»‡ch
    task.wait(0.25)

    local prompt = gen:FindFirstChild("Main") and gen.Main:FindFirstChild("Prompt")
    if prompt then
        prompt.HoldDuration = 0
        prompt.RequiresLineOfSight = false
        prompt.MaxActivationDistance = 99999

        pcall(function()
            prompt:InputHoldBegin()
            prompt:InputHoldEnd()
        end)
    end

    if gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
        gen.Remotes.RE:FireServer()
    end

    if prompt then
        task.wait(0)
        pcall(function()
            for i = 1, 3 do
                prompt:InputHoldBegin()
                task.wait(0)
                prompt:InputHoldEnd()
            end
        end)
    end

    solveGeneratorCooldown = true
    task.delay(genDelay, function()
        solveGeneratorCooldown = false
    end)
end

Tabs.Farm:AddToggle("SurvivorsAutoFarmV2", {
    Title = "Survivors Farm V2",
    Default = false
}):OnChanged(function(Value)
    _G.SurvivorsFarm = Value

    task.spawn(function()
        while _G.SurvivorsFarm do
            Spectators = {}
            for _, v in ipairs(workspace:WaitForChild("Players"):WaitForChild("Spectating"):GetChildren()) do
                table.insert(Spectators, v.Name)
            end
            isInGame = not table.find(Spectators, LP.Name)
            task.wait(0.1)
        end
    end)

    task.spawn(function()
        while _G.SurvivorsFarm do
            if workspace:FindFirstChild("Players") then
                local survivorsFolder = workspace.Players:FindFirstChild("Survivors")
                Survivor = survivorsFolder 
                    and (survivorsFolder:FindFirstChild(LP.Name) 
                    or table.find(survivorsFolder:GetChildren(), LP.Character))
            end
            task.wait(0.1)
        end
    end)

    task.spawn(function()
        local survivorsFolder = workspace.Players:WaitForChild("Survivors")
        while _G.SurvivorsFarm do
            if Survivor and isInGame then
                for _, surv in ipairs(survivorsFolder:GetChildren()) do
                    if surv:GetAttribute("Username") == LP.Name then
                        currentCharacter = surv
                        break
                    end
                end

                local gens = getUnfinishedGenerators()
                for _, gen in ipairs(gens) do
                    if not _G.SurvivorsFarm then break end
                    fixOneGenerator(gen)
                    task.wait(genDelay)
                end
            end
            task.wait(0.1)
        end
    end)
end)







    Tabs.Farm:AddSection("â†³ Generator")

do
local solveGeneratorCooldown = false
local AutoFinishGen = false
local genDelay = 1.5

local function getClosestGenerator()
    local char = game.Players.LocalPlayer.Character
    if not char or not char.PrimaryPart then return nil end

    local root = char.PrimaryPart
    local closest, shortestDist = nil, math.huge

    local mapContainer = workspace:FindFirstChild("Map")
    if mapContainer then
        local ingame = mapContainer:FindFirstChild("Ingame")
        if ingame then
            local map = ingame:FindFirstChild("Map")
            if map then
                for _, obj in ipairs(map:GetChildren()) do
                    if obj.Name == "Generator" and obj:IsA("Model") and obj.PrimaryPart then
                        local dist = (root.Position - obj.PrimaryPart.Position).Magnitude
                        if dist < shortestDist then
                            closest = obj
                            shortestDist = dist
                        end
                    end
                end
            end
        end
    end
    return closest
end

Tabs.Farm:AddButton({
    Title = "Finish Generator",
    Callback = function()
        if solveGeneratorCooldown then 
            print("â³ Please wait before trying again!") 
            return
        end
        if AutoFinishGen then
            print("âŒ Please disable Auto Finish Generator first!")
            return
        end

        local gen = getClosestGenerator()
        if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
            gen.Remotes.RE:FireServer()
            solveGeneratorCooldown = true
            task.delay(genDelay, function()
                solveGeneratorCooldown = false
            end)
        end
    end
})

Tabs.Farm:AddToggle("AutoFinishGen", {
    Title = "Auto Finish Generator",
    Default = false
}):OnChanged(function(state)
    AutoFinishGen = state

    if state then
        if solveGeneratorCooldown then
            print("âš ï¸ Please wait cooldown before enabling Auto Finish!") 
            Fluent.Options.AutoFinishGen:SetValue(false)
            return
        end

        task.spawn(function()
            while AutoFinishGen do
                local gen = getClosestGenerator()
                if gen and gen:FindFirstChild("Remotes") and gen.Remotes:FindFirstChild("RE") then
                    gen.Remotes.RE:FireServer()
                end
                solveGeneratorCooldown = true
                task.wait(genDelay)
                solveGeneratorCooldown = false
            end
        end)
    else
        solveGeneratorCooldown = false
    end
end)


Tabs.Farm:AddInput("GenDelayInput", {
    Title = "Enter Delay",
    Default = "1.5",
    Placeholder = "Write Here (1.5-10)",
    Numeric = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            -- Clamp giÃ¡ trá»‹ tá»« 1.5 Ä‘áº¿n 10
            genDelay = math.clamp(num, 1.5, 10)
            print("â± Delay set to:", genDelay)
        else
            print("âš ï¸ Nháº­p sá»‘ há»£p lá»‡!")
        end
    end
})
end





    Tabs.Farm:AddSection("â†³ Items")

local Players = game:GetService("Players")
local LP = Players.LocalPlayer

local function pickUpNearest()
    local map = workspace:FindFirstChild("Map") 
                and workspace.Map:FindFirstChild("Ingame") 
                and workspace.Map.Ingame:FindFirstChild("Map")
    if not map or not LP.Character or not LP.Character:FindFirstChild("HumanoidRootPart") then return end

    local oldCFrame = LP.Character.HumanoidRootPart.CFrame
    for _, item in ipairs(map:GetChildren()) do
        if item:IsA("Tool") and item:FindFirstChild("ItemRoot") 
           and item.ItemRoot:FindFirstChild("ProximityPrompt") then
            LP.Character.HumanoidRootPart.CFrame = item.ItemRoot.CFrame
            task.wait(0.3)
            fireproximityprompt(item.ItemRoot.ProximityPrompt)
            task.wait(0.4)
            LP.Character.HumanoidRootPart.CFrame = oldCFrame
            break
        end
    end
end

Tabs.Farm:AddButton({
    Title = "Pick Up Item",
    Callback = pickUpNearest
})

Tabs.Farm:AddToggle("ItemPick", {
    Title = "Auto PickUp Item",
    Default = false
}):OnChanged(function(Value)
    _G.PickupItem = Value
    if not Value then return end

    task.spawn(function()
        while _G.PickupItem do
            pickUpNearest()
            task.wait(0.2) -- delay giá»¯a má»—i láº§n nháº·t
        end
    end)
end)




-- Tabs.Main


    Tabs.Main:AddSection("â†³ Eliot")

Tabs.Main:AddToggle("PizzaAim_Toggle", {
    Title = "Pizza Aimbot",
    Default = getgenv().PizzaSystem.AimbotEnabled,
}):OnChanged(function(state)
    getgenv().PizzaSystem.AimbotEnabled = state
end)

Tabs.Main:AddInput("PizzaAimDistance", {
    Title = "Aim Distance",
    Default = tostring(getgenv().PizzaSystem.AimDistance),
}):OnChanged(function(value)
    local n = tonumber(value)
    if n then
        getgenv().PizzaSystem.AimDistance = n
    end
end)

Tabs.Main:AddToggle("AutoEatPizza", {
    Title = "Auto Eat Pizza",
    Default = getgenv().PizzaSystem.AutoEatEnabled,
}):OnChanged(function(state)
    getgenv().PizzaSystem.AutoEatEnabled = state
end)

Tabs.Main:AddInput("PizzaHPThreshold", {
    Title = "HP Threshold",
    Default = tostring(getgenv().PizzaSystem.HPThreshold),
}):OnChanged(function(value)
    local n = tonumber(value)
    if n then getgenv().PizzaSystem.HPThreshold = n end
end)




    Tabs.Main:AddSection("â†³Chance")

local Aimbot = _G.AimbotManager
if not Aimbot then
    warn("[AimbotGUI] _G.AimbotManager not found. Make sure AimbotLogic.lua is loaded first.")
end

Tabs.Main:AddDropdown("AimMode", {
    Title = "Aim Mode",
    Values = {"Normal", "Faster", "Reflex"},
    Default = Aimbot and Aimbot.GetAimMode() or "Normal",
}):OnChanged(function(val)
    if Aimbot then Aimbot.SetAimMode(val) end
end)

Tabs.Main:AddDropdown("PredictionMode", {
    Title = "Prediction Mode",
    Values = {"Speed", "Ping", "front", "No Lag"},
    Default = Aimbot and Aimbot.GetPredictionMode() or "Speed",
}):OnChanged(function(val)
    if Aimbot then Aimbot.SetPredictionMode(val) end
end)

Tabs.Main:AddDropdown("CoinflipChargeDropdown", {
    Title = "Select Score",
    Values = {"1 Point", "2 Point", "3 Point"},
    Default = tostring((Aimbot and Aimbot.GetConfig() and Aimbot.GetConfig().coinflipTargetCharge) or "3") .. " Point",
}):OnChanged(function(val)
    local num = tonumber(val and val:match("%d+"))
    if num and Aimbot then Aimbot.SetCoinflipTargetScore(num) end
end)

Tabs.Main:AddInput("CoinflipDistance", {
    Title = "Distance",
    Default = tostring((Aimbot and Aimbot.GetConfig() and Aimbot.GetConfig().coinflipBlockDist) or 50),
    Placeholder = "Enter studs",
}):OnChanged(function(val)
    local num = tonumber(val)
    if num and Aimbot then Aimbot.SetCoinflipDistance(num) end
end)

Tabs.Main:AddToggle("BlockCoinflipToggle", {
    Title = "Safe Mode",
    Default = (Aimbot and Aimbot.GetConfig() and Aimbot.GetConfig().blockCoinflipWhenClose) or true,
}):OnChanged(function(state)
    if Aimbot then Aimbot.SetBlockCoinflipWhenClose(state) end
end)

Tabs.Main:AddToggle("OffsetToggle", {
    Title = "Enable Offset",
    Default = (Aimbot and Aimbot.GetConfig() and Aimbot.GetConfig().useOffset) or true,
}):OnChanged(function(state)
    if Aimbot then Aimbot.SetUseOffset(state) end
end)

Tabs.Main:AddToggle("AimbotToggle", {
    Title = "Auto Aim Shoot",
    Default = (Aimbot and Aimbot.GetActive()) or false,
}):OnChanged(function(state)
    if Aimbot then Aimbot.SetActive(state) end
end)

Tabs.Main:AddToggle("AutoCoinflipToggle", {
    Title = "Auto Coin Flip",
    Default = (Aimbot and Aimbot.GetConfig() and Aimbot.GetConfig().autoCoinflip) or false,
}):OnChanged(function(state)
    if Aimbot then Aimbot.SetCoinflipEnabled(state) end
end)



    Tabs.Main:AddSection("â†³ Two Time")

local Logic = _G.AutoBackstabLogic

Tabs.Main:AddDropdown("BackstabMode", {
    Title = "Backstab Mode",
    Values = { "AI Aimbot", "Player Aimbot" },
    Default = "AI Aimbot",
}):OnChanged(function(value)
    Logic.SetMode(value)
    print("ðŸŽ¯ Backstab Mode:", value)
end)

Tabs.Main:AddToggle("AutoBackstab", {
    Title = "Auto Backstab V2",
    Default = false
}):OnChanged(function(state)
    Logic.SetEnabled(state)
    print("ðŸ”ª Auto Backstab:", state and "ON" or "OFF")
end)

Tabs.Main:AddInput("BackstabRadiusInput", {
    Title = "Check Radius",
    Default = "18",
    Numeric = true,
    Callback = function(value)
        local num = tonumber(value)
        if num then
            Logic.SetRadius(math.clamp(num, 1, 50))
            print("ðŸ“ Check Radius set to:", num)
        end
    end
})



    Tabs.Main:AddSection("â†³ 007n7")

Tabs.Main:AddToggle("InstantInvisibleV2", {
    Title = "Instant Invisible",
    Default = getgenv().InvisibleSystem.InstantEnabled,
}):OnChanged(function(v)
    getgenv().InvisibleSystem.InstantEnabled = v
end)

Tabs.Main:AddToggle("InvisibleCloneV2", {
    Title = "Invisible if cloned",
    Default = getgenv().InvisibleSystem.CloneEnabled,
}):OnChanged(function(v)
    getgenv().InvisibleSystem.CloneEnabled = v
end)


    Tabs.Main:AddSection("â†³ Veeronica")

Tabs.Main:AddToggle("AutoTrick", {
    Title = "Auto Trick V2",
    Default = false,
    Callback = function(Value)
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local Players = game:GetService("Players")
        local VirtualInputManager = game:GetService("VirtualInputManager")

        local player = Players.LocalPlayer
        local device = "Mobile"

        local function getBehaviorFolder()
            local ok, folder = pcall(function()
                return ReplicatedStorage.Assets.Survivors.Veeronica.Behavior
            end)
            return ok and folder
        end

        local function getSprintingButton()
            local gui = player:FindFirstChild("PlayerGui")
            if not gui then return end
            local main = gui:FindFirstChild("MainUI")
            if not main then return end
            return main:FindFirstChild("SprintingButton")
        end

        local function adorneeIsPlayerCharacter(h)
            if not h then return false end
            local adornee = h.Adornee
            local char = player.Character
            if not adornee or not char then return false end
            return adornee == char or adornee:IsDescendantOf(char)
        end

        local function triggerSprint()
            if device ~= "Mobile" then return end
            local btn = getSprintingButton()
            if not btn then return end
            local conns = getconnections(btn.MouseButton1Down)
            for _, v in pairs(conns) do
                pcall(function()
                    v:Fire()
                    if v.Function then v:Function() end
                end)
            end
        end

        local function cleanup()
            if _G.AutoTrick_Connections then
                for _, conn in ipairs(_G.AutoTrick_Connections) do
                    if conn and conn.Connected then
                        conn:Disconnect()
                    end
                end
                _G.AutoTrick_Connections = nil
            end
            if _G.AutoTrick_Loop then
                task.cancel(_G.AutoTrick_Loop)
                _G.AutoTrick_Loop = nil
            end
            print("[AutoTrick] Disabled")
        end

        if Value then
            print("[AutoTrick] Enabled")

            local behaviorFolder = getBehaviorFolder()
            if not behaviorFolder then
                warn("[AutoTrick] Behavior folder not found.")
                return
            end

            local highlights = {}
            _G.AutoTrick_Connections = {}

            local addConn = behaviorFolder.DescendantAdded:Connect(function(child)
                if child:IsA("Highlight") then
                    highlights[child] = true
                end
            end)

            local removeConn = behaviorFolder.DescendantRemoving:Connect(function(child)
                if child:IsA("Highlight") then
                    highlights[child] = nil
                end
            end)

            table.insert(_G.AutoTrick_Connections, addConn)
            table.insert(_G.AutoTrick_Connections, removeConn)

            _G.AutoTrick_Loop = task.spawn(function()
                while task.wait(0.3) do
                    if not Value then break end
                    for h in pairs(highlights) do
                        if adorneeIsPlayerCharacter(h) then
                            triggerSprint()
                            break
                        end
                    end
                end
            end)

        else
            cleanup()
        end
    end
})




    Tabs.Main:AddSection("â†³ Guest1337")




do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer

    local Killers = {
        ["Slasher"] = true,
        ["1x1x1x1"] = true,
        ["c00lkidd"] = true,
        ["Noli"] = true,
        ["JohnDoe"] = true,
        ["Guest 666"] = true,
        ["Sixer"] = true
    }

    local function isKiller(player)
        local char = player.Character
        if not char then return false end
        return Killers[char.Name] == true
    end

    local animationIds = {
        ["83829782357897"]  = true, -- Slash, 1x1x1x1
        ["126830014841198"] = true, -- Slash, Jason
        ["126355327951215"] = true, -- Behead, Jason
        ["121086746534252"] = true, -- GashingWoundStart, Jason
        ["105458270463374"] = true, -- Slash, JohnDoe
        ["18885909645"]     = true, -- Attack, c00lkid
        ["94162446513587"]  = true, -- Slash, JohnDoe, Skin: !Joner
        ["93069721274110"]  = true, -- Slash, JohnDoe, Skin: AnnihilationJohnDoe
        ["97433060861952"]  = true, -- Slash, JohnDoe, Skin: #SK
        ["121293883585738"] = true, -- Slash, 1x1x1x1
        ["92173139187970"]  = true, -- Slash, Skin: Hacklord1x1x1x1
        ["106847695270773"] = true, -- GashingWoundStart, Jason, Skin: Subject0Jason
        ["125403313786645"] = true, -- Slash, Jason, Skin: Subject0Jason
        ["81639435858902"]  = true, -- Behead, Jason, Skin: WhitePumpkinJason
        ["137314737492715"] = true, -- GashingWoundStart, Jason, Skin: WhitePumpkinJason
        ["120112897026015"] = true, -- Slash, Jason, Skin: WhitePumpkinJason
        ["82113744478546"]  = true, -- Behead, Jason (nhiá»u skin)
        ["118298475669935"] = true, -- Slash, Jason (nhiá»u skin)
        ["126681776859538"] = true, -- Behead, Jason, Skin: PursuerJason
        ["129976080405072"] = true, -- GashingWoundStart, Jason, Skin: PursuerJason
        ["109667959938617"] = true, -- Slash, Jason, Skin: PursuerJason
        ["74707328554358"]  = true, -- Slash, Jason, Skin: #DeadRabbitsJason
        ["133336594357903"] = true, -- Behead, Jason, Skin: #DeadRabbitsJason
        ["86204001129974"]  = true, -- GashingWoundStart, Jason, Skin: #DeadRabbitsJason
        ["70371667919898"]  = true, -- Attack, c00lkidd, Skin: MafiosoC00l
        ["131543461321709"] = true, -- Attack, c00lkidd, Skin: SaviorC00l
        ["106776364623742"] = true, -- Walkspeed Overing, c00lkidd (all skins)
        ["136323728355613"] = true, -- Swing, Noli
        ["109230267448394"] = true, -- Swing, Noli (all skins)
        ["139835501033932"] = true, -- VoidRush, Noli (all skins)
        ["114356208094580"] = true, -- VoidRush2, Noli
        ["106538427162796"] = true, -- Stab, All Noli
        ["126896426760253"] = true, -- VoidRush, Noli
        ["131430497821198"] = true, -- MassInfection, 1x1x1x1
        ["100592913030351"] = true, -- MassInfection, 1x1x1x1 (Fleskhjerta/AceOfSpades/Lancer)
        ["70447634862911"]  = true, -- MassInfection, Skin: Hacklord1x1x1x1 Old
        ["83685305553364"]  = true, -- MassInfection, Skin: Hacklord1x1x1x1 New
        ["126171487400618"]  = true, -- Slash, Skin: Hacklord1x1x1x1
        ["97167027849946"]  = true, -- Noli Dash Belike
        ["99135633258223"]  = true,
        ["98456918873918"]  = true,
        ["83251433279852"]  = true,
        ["126681776859538"] = true,
        ["129976080405072"] = true,
        ["122709416391891"] = true, -- ÄÃ¡nh ThÆ°á»ng Guest 666
        ["87989533095285"] = true, -- Vá»“ Tá»›i Guest 666
        ["139309647473555"] = true, -- Bay Äáº¿n Má»¥c TiÃªu
        ["133363345661032"] = true, -- Chuáº©n Bá»‹ Bay Äáº¿n Má»¥c tiÃªu
        ["128414736976503"] = true, -- Sáºµn SÃ ng Bay Äáº¿n
        ["77375846492436"] = true, -- Noli Aful Rework
        ["92445608014276"] = true, -- NAR
        ["100358581940485"] = true, -- NAR
        ["91758760621955"] = true, -- NAR
        ["94634594529334"] = true, -- NAR
        ["90620531468240"] = true, -- 1x slash m2-3 rework
        ["94958041603347"] = true, -- Slasher BÃ­ ngÃ´ tráº¯ng / chÃ©m
        ["131642454238375"] = true, -- Slasher BÃ­ NgÃ´ tráº¯ng / KhÃ³a skill
        ["110702884830060"] = true, -- Slasher BÃ­ NgÃ´ Tráº¯ng / LiÃªn HoÃ n ChÃ©m
        ["76312020299624"] = true, -- Noli Admin Void rush
        ["126654961540956"] = true, -- NAVR
        ["139613699193400"] = true, -- NAVR
        ["91509234639766"] = true, -- NA ÄÃ¡nh ThÆ°á»ng
        ["105458270463374"] = true, -- John Doe M3 vÃ  M4 ÄÃ¡nh ThÆ°á»ng
        ["114506382930939"] = true, -- 1x Skin Martyr ChÃ©m ThÆ°á»ng
    }

    local delayedAnimations = {}

    local toggleOn = false
    local strictRangeOn = false
    local detectionRange = 18

    local blockRemote
    local blockButton, connections = nil, {}

    local function findBlockRemote()
        if blockRemote then return blockRemote end
        if not blockButton then return nil end
        for _, conn in ipairs(getconnections(blockButton.MouseButton1Click)) do
            local f = conn.Function
            if f and islclosure(f) then
                local upvals = getupvalues(f)
                for _, v in pairs(upvals) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        blockRemote = v
                        warn("[AutoBlock] Found Block Remote:", v:GetFullName())
                        return blockRemote
                    end
                end
            end
        end
        return nil
    end

    local function initBlockButton()
        local gui = localPlayer:FindFirstChild("PlayerGui")
        if not gui then return end
        local mainUI = gui:FindFirstChild("MainUI")
        local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
        blockButton = container and container:FindFirstChild("Block")
        if blockButton and blockButton:IsA("ImageButton") then
            connections = getconnections(blockButton.MouseButton1Click)
            findBlockRemote()
        end
    end

    initBlockButton()
    localPlayer.CharacterAdded:Connect(function()
        task.wait(0)
        initBlockButton()
    end)

    local function fastBlock()
        if blockRemote then
            pcall(function()
                blockRemote:FireServer(true)
                task.delay(1e-10, function()
                    blockRemote:FireServer(false)
                end)
            end)
        else
            if not blockButton or not blockButton.Visible then return end
            for _, conn in ipairs(connections) do
                pcall(function() conn:Fire() end)
            end
            pcall(function() blockButton:Activate() end)
        end
    end

    local lastTeleport = 0
    local function teleportDodge(killerChar)
        local now = tick()
        if now - lastTeleport < 5 then return end
        lastTeleport = now

        local myChar = localPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        local killerRoot = killerChar and killerChar:FindFirstChild("HumanoidRootPart")
        if not (myRoot and killerRoot) then return end

        local oldCFrame = myRoot.CFrame
        local forward = killerRoot.CFrame.LookVector

        myRoot.CFrame = killerRoot.CFrame + forward * 7.5

        task.delay(0.1, function()
            if myRoot then
                myRoot.CFrame = oldCFrame
            end
        end)
    end

    local function getBoolFlag(name, default)
        local flag = localPlayer:FindFirstChild(name)
        if not flag then
            flag = Instance.new("BoolValue")
            flag.Name = name
            flag.Value = default
            flag.Parent = localPlayer
        end
        return flag
    end

    local function getNumberFlag(name, default)
        local flag = localPlayer:FindFirstChild(name)
        if not flag then
            flag = Instance.new("NumberValue")
            flag.Name = name
            flag.Value = default
            flag.Parent = localPlayer
        end
        return flag
    end

    local toggleFlag = getBoolFlag("AutoBlockToggle", false)
    local strictFlag = getBoolFlag("AutoBlockStrictRange", false)
    local rangeFlag = getNumberFlag("AutoBlockRange", 18)

    toggleOn = toggleFlag.Value
    strictRangeOn = strictFlag.Value
    detectionRange = rangeFlag.Value

    Tabs.Main:AddToggle("AutoBlockV2", {Title = "Auto Block V3", Default = toggleOn})
        :OnChanged(function(state)
            toggleOn = state
            toggleFlag.Value = state
        end)

    Tabs.Main:AddToggle("StrictRangeCheck", {Title = "Auto Check V3", Default = strictRangeOn})
        :OnChanged(function(state)
            strictRangeOn = state
            strictFlag.Value = state
        end)

    Tabs.Main:AddInput("RangeCheckInput", {
        Title = "Range Check",
        Default = tostring(detectionRange),
        Placeholder = "Enter detection range"
    }):OnChanged(function(txt)
        local val = tonumber(txt)
        if val then
            detectionRange = val
            rangeFlag.Value = val
        end
    end)

    local playerConns = {}
    local recentBlocks = {}
    local COOLDOWN_ZERO, COOLDOWN_MISS = 0, 0

    local function cleanupPlayerConns(p)
        local tbl = playerConns[p]
        if tbl then
            for _, c in ipairs(tbl) do
                if c and c.Disconnect then c:Disconnect() end
            end
            playerConns[p] = nil
        end
        recentBlocks[p.UserId] = nil
    end

    local function shouldBlockNow(p, animId, track)
        recentBlocks[p.UserId] = recentBlocks[p.UserId] or {}
        local last = recentBlocks[p.UserId][animId] or 0
        local now = tick()
        if track.TimePosition <= 0 then
            if now - last >= COOLDOWN_ZERO then
                recentBlocks[p.UserId][animId] = now
                return true
            end
            return false
        else
            if now - last >= COOLDOWN_MISS then
                recentBlocks[p.UserId][animId] = now
                return true
            end
            return false
        end
    end

    local massInfectionIds = {
        ["131430497821198"] = true,
        ["100592913030351"] = true,
        ["70447634862911"]  = true,
        ["83685305553364"]  = true,
        ["101101433684051"] = true,
        ["109777684604906"] = true,
    }

    local function onAnimationPlayed(player, char, track)
        if not toggleOn then return end
        if not (track and track.Animation) then return end
        local animIdStr = track.Animation.AnimationId
        local id = animIdStr and string.match(animIdStr, "%d+")
        if not id or not animationIds[id] then return end

        if strictRangeOn then
            local myChar = localPlayer.Character
            local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
            local root = char and char:FindFirstChild("HumanoidRootPart")
            if not myRoot or not root then return end
            local dist = (root.Position - myRoot.Position).Magnitude
            if dist > detectionRange then return end
        end

        if shouldBlockNow(player, id, track) then
            if massInfectionIds[id] then
                task.delay(0.5, fastBlock) -- delay 0.5s cho MassInfection
            else
                fastBlock()
            end

            if isKiller(player) and delayedAnimations[id] then
                teleportDodge(char)
            end
        end
    end

    local function monitorCharacter(player, char)
        if not player or not char then return end
        local hum = char:FindFirstChildOfClass("Humanoid") or char:WaitForChild("Humanoid", 5)
        if not hum then return end
        local con = hum.AnimationPlayed:Connect(function(track)
            task.spawn(onAnimationPlayed, player, char, track)
        end)
        playerConns[player] = playerConns[player] or {}
        table.insert(playerConns[player], con)
    end

    local function onPlayerAdded(player)
        if player == localPlayer then return end
        if player.Character then monitorCharacter(player, player.Character) end
        local conCharAdded = player.CharacterAdded:Connect(function(char)
            task.wait(0)
            monitorCharacter(player, char)
        end)
        playerConns[player] = playerConns[player] or {}
        table.insert(playerConns[player], conCharAdded)
    end

    for _, p in ipairs(Players:GetPlayers()) do onPlayerAdded(p) end
    Players.PlayerAdded:Connect(onPlayerAdded)
    Players.PlayerRemoving:Connect(cleanupPlayerConns)

    local circles = {}

    local function createCircleFor(player, hrp)
        if circles[player] then circles[player]:Destroy() end
        local circle = Instance.new("Part")
        circle.Anchored, circle.CanCollide = true, false
        circle.Shape = Enum.PartType.Cylinder
        circle.Size = Vector3.new(0.2, detectionRange * 2, detectionRange * 2)
        circle.CFrame = hrp.CFrame * CFrame.Angles(0, 0, math.rad(90))
        circle.Material, circle.Transparency = Enum.Material.Neon, 0.5
        circle.Color = Color3.fromRGB(255, 0, 0)
        circle.Parent = workspace
        circles[player] = circle
    end

    local function removeCircle(player)
        if circles[player] then circles[player]:Destroy() circles[player] = nil end
    end

    RunService.Heartbeat:Connect(function()
        if not strictRangeOn then
            for _, circle in pairs(circles) do
                if circle then circle.Transparency = 1 end
            end
            return
        end
        local myChar = localPlayer.Character
        local myRoot = myChar and myChar:FindFirstChild("HumanoidRootPart")
        if not myRoot then return end
        for _, player in ipairs(Players:GetPlayers()) do
            if player ~= localPlayer then
                local char = player.Character
                local hrp = char and char:FindFirstChild("HumanoidRootPart")
                local hum = char and char:FindFirstChildOfClass("Humanoid")
                if hrp and hum and hum.Health > 0 and isKiller(player) then
                    if not circles[player] then createCircleFor(player, hrp) end
                    local circle = circles[player]
                    circle.Size = Vector3.new(0.2, detectionRange * 2, detectionRange * 2)
                    circle.CFrame = hrp.CFrame * CFrame.Angles(0, 0, math.rad(90))
                    local dist = (myRoot.Position - hrp.Position).Magnitude
                    circle.Color = (dist <= detectionRange) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
                    circle.Transparency = 0.5
                else
                    removeCircle(player)
                end
            end
        end
    end)

    Players.PlayerRemoving:Connect(removeCircle)
end








do
    local autoPunchOn, aimPunch, flingPunchOn, customPunchEnabled = false, false, false, false
    local hiddenfling = false
    local flingPower = 10000
    local predictionValue = 4
    local customPunchAnimId = ""
    local Humanoid
    local lastPunchTime = 0
    local punchAnimIds = { "87259391926321" }
    local LP = game:GetService("Players").LocalPlayer
    local RunService = game:GetService("RunService")
    local PlayerGui = LP:WaitForChild("PlayerGui")

    local function playCustomPunch(animId)
        if not Humanoid then return end
        if not animId or animId == "" then return end
        local now = tick()
        if now - lastPunchTime < 1 then return end

        for _, track in ipairs(Humanoid:GetPlayingAnimationTracks()) do
            local animNum = tostring(track.Animation.AnimationId):match("%d+")
            if table.find(punchAnimIds, animNum) then
                track:Stop()
            end
        end

        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. animId
        local track = Humanoid:LoadAnimation(anim)
        track:Play()
        lastPunchTime = now
    end

    coroutine.wrap(function()
        local hrp, c, vel, movel = nil, nil, nil, 0.1
        while true do
            RunService.Heartbeat:Wait()
            if hiddenfling then
                while hiddenfling and not (c and c.Parent and hrp and hrp.Parent) do
                    RunService.Heartbeat:Wait()
                    c = LP.Character
                    hrp = c and c:FindFirstChild("HumanoidRootPart")
                end
                if hiddenfling then
                    vel = hrp.Velocity
                    hrp.Velocity = vel * flingPower + Vector3.new(0, flingPower, 0)
                    RunService.RenderStepped:Wait()
                    hrp.Velocity = vel
                    RunService.Stepped:Wait()
                    hrp.Velocity = vel + Vector3.new(0, movel, 0)
                    movel = movel * -1
                end
            end
        end
    end)()

    RunService.RenderStepped:Connect(function()
        local myChar = LP.Character
        if not myChar then return end
        local myRoot = myChar:FindFirstChild("HumanoidRootPart")
        Humanoid = myChar:FindFirstChildOfClass("Humanoid")

        if autoPunchOn then
            local gui = PlayerGui:FindFirstChild("MainUI")
            local punchBtn = gui and gui:FindFirstChild("AbilityContainer") and gui.AbilityContainer:FindFirstChild("Punch")
            local charges = punchBtn and punchBtn:FindFirstChild("Charges")

            if charges and charges.Text == "1" then
                local killerNames = {"c00lkidd", "Slasher", "JohnDoe", "1x1x1x1", "Noli", "Guest 666", "Sixer"}
                for _, name in ipairs(killerNames) do
                    local killer = workspace:FindFirstChild("Players")
                        and workspace.Players:FindFirstChild("Killers")
                        and workspace.Players.Killers:FindFirstChild(name)

                    if killer and killer:FindFirstChild("HumanoidRootPart") then
                        local root = killer.HumanoidRootPart
                        if root and myRoot and (root.Position - myRoot.Position).Magnitude <= 10 then

                            if aimPunch then
                                local humanoid = myChar:FindFirstChild("Humanoid")
                                if humanoid then humanoid.AutoRotate = false end
                                task.spawn(function()
                                    local start = tick()
                                    while tick() - start < 2 do
                                        if myRoot and root and root.Parent then
                                            local predictedPos = root.Position + (root.CFrame.LookVector * predictionValue)
                                            myRoot.CFrame = CFrame.lookAt(myRoot.Position, predictedPos)
                                        end
                                        task.wait()
                                    end
                                    if humanoid then humanoid.AutoRotate = true end
                                end)
                            end

                            for _, conn in ipairs(getconnections(punchBtn.MouseButton1Click)) do
                                pcall(function() conn:Fire() end)
                            end

                            if flingPunchOn then
                                hiddenfling = true
                                task.spawn(function()
                                    local start = tick()
                                    while tick() - start < 1 do
                                        if LP.Character and LP.Character:FindFirstChild("HumanoidRootPart") and root and root.Parent then
                                            local frontPos = root.Position + (root.CFrame.LookVector * 2)
                                            LP.Character.HumanoidRootPart.CFrame = CFrame.new(frontPos, root.Position)
                                        end
                                        task.wait()
                                    end
                                    hiddenfling = false
                                end)
                            end

                            if customPunchEnabled and customPunchAnimId ~= "" then
                                playCustomPunch(customPunchAnimId)
                            end

                            break
                        end
                    end
                end
            end
        end
    end)

    Tabs.Main:AddToggle("AutoPunch", { Title = "Auto Punch", Default = false })
        :OnChanged(function(val) autoPunchOn = val end)

    Tabs.Main:AddToggle("AimPunch", { Title = "Punch Aimbot", Default = false })
        :OnChanged(function(val) aimPunch = val end)

    Tabs.Main:AddToggle("FlingPunch", { Title = "Fling Punch", Default = false })
        :OnChanged(function(val) flingPunchOn = val end)

    Tabs.Main:AddSlider("Prediction", {
        Title = "Aim Prediction",
        Min = 0, Max = 10, Default = 4, Rounding = 1,
    }):OnChanged(function(val) predictionValue = val end)

    Tabs.Main:AddSlider("FlingPower", {
        Title = "Fling Power",
        Min = 5000, Max = 500000, Default = 10000, Rounding = 0,
    }):OnChanged(function(val) flingPower = val end)

    Tabs.Main:AddInput("CustomAnim", {
        Title = "Custom Punch",
        Default = "",
        Placeholder = "Enter Animation ID"
    }):OnChanged(function(txt) customPunchAnimId = txt end)

    Tabs.Main:AddToggle("EnableCustomAnim", { Title = "Enable Custom Animation", Default = false })
        :OnChanged(function(val) customPunchEnabled = val end)
end




    Tabs.Main:AddSection("â†³ Noli")

Tabs.Main:AddToggle("VoidRushControl", {
    Title = "Void Rush Aimbot",
    Default = getgenv().VoidRushControl and getgenv().VoidRushControl.Enabled or false
}):OnChanged(function(v)
    getgenv().VoidRushControl = getgenv().VoidRushControl or {}
    getgenv().VoidRushControl.Enabled = v

    if _G.VoidRushLogic then
        _G.VoidRushLogic.SetEnabled(v)
    end
end)

-- Tabs.Event

    Tabs.Event:AddSection("â†³ Halloween")

local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local HRP = Character:FindFirstChild("HumanoidRootPart")

local function onCharacterAdded(char)
    Character = char
    Humanoid = Character:WaitForChild("Humanoid")
    HRP = Character:WaitForChild("HumanoidRootPart")
end
LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

local function getHumanoidAndHRP()
    local char = LocalPlayer.Character
    if not char then return nil, nil end
    local hum = char:FindFirstChildOfClass("Humanoid")
    local hrp = char:FindFirstChild("HumanoidRootPart")
    return hum, hrp
end

Tabs.Event:AddButton({
    Title = "TP to Shop",
    Description = "Teleport Ä‘áº¿n khu Shop",
    Callback = function()
        local _, hrp = getHumanoidAndHRP()
        if hrp then
            hrp.CFrame = CFrame.new(-3540.36, -392.73, 231.53)
        end
    end,
})

local allowedModels = {
    ["dumsek"]=true, ["toon dusek"]=true, ["dusek"]=true,
    ["umdum"]=true, ["doothsek"]=true
}
local blockedCenter = Vector3.new(-3485.02, 4.48, 217.77)
local blockedRadius = 500

local function isValidModel(model)
    if not model or not model:IsDescendantOf(workspace) then return false end
    if not allowedModels[model.Name:lower()] then return false end
    local part = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
    if not part then return false end
    return (part.Position - blockedCenter).Magnitude > blockedRadius
end

_G.ESPManager:RegisterType("Sukkars", Color3.fromRGB(0,85,255), isValidModel, false)

local oldCreate = _G.ESPManager.Create
_G.ESPManager.Create = function(self, model, typeName)
    oldCreate(self, model, typeName)
    if typeName ~= "Sukkars" then return end

    local part = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
    if part and not part:FindFirstChild("_TouchedFlag") then
        local flag = Instance.new("BoolValue")
        flag.Name = "_TouchedFlag"
        flag.Parent = part
        part.Touched:Connect(function(hit)
            local char = LocalPlayer.Character
            if char and hit:IsDescendantOf(char) then
                _G.ESPManager:Remove(model)
            end
        end)
    end
end

task.spawn(function()
    while task.wait(0.15) do
        local _, hrp = getHumanoidAndHRP()
        if not hrp then continue end
        for model, data in pairs(_G.ESPManager.Objects) do
            if data.type == "Sukkars" then
                local part = model:FindFirstChild("HumanoidRootPart") or model:FindFirstChildWhichIsA("BasePart")
                if part then
                    local dist = (hrp.Position - part.Position).Magnitude
                    if dist <= 5 or dist > 1200 then
                        _G.ESPManager:Remove(model)
                    end
                else
                    _G.ESPManager:Remove(model)
                end
            end
        end
    end
end)

Tabs.Event:AddToggle("ESPSukkarsToggle", {
    Title = "ESP Sukkars",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Sukkars", state)
end)

local TargetNames = {"dumsek","toon dusek","umdum","dusek","doothsek"}
local ScanInterval = 0.5
local TeleportDelay = 0.25
local HeightSafe = 5
local IgnoreCenter = blockedCenter
local IgnoreRadius = blockedRadius

local autoTeleport = false
local visitedModels = {}
local currentTarget = nil

local function getModelCFrame(model)
    if not model or not model:IsDescendantOf(workspace) then return end
    local part = model:FindFirstChild("HumanoidRootPart") or model.PrimaryPart or model:FindFirstChildWhichIsA("BasePart")
    if part then return part.CFrame end
    if model.GetPivot then
        local ok, pivot = pcall(function() return model:GetPivot() end)
        if ok then return pivot end
    end
end

local function isAutoValid(model)
    if not model or not model:IsDescendantOf(workspace) then return false end
    for _, name in ipairs(TargetNames) do
        if model.Name:lower() == name:lower() then
            local cf = getModelCFrame(model)
            if cf then
                return (cf.Position - IgnoreCenter).Magnitude > IgnoreRadius
            end
        end
    end
    return false
end

local function findTargets()
    local list = {}
    for _, obj in ipairs(workspace:GetDescendants()) do
        if obj:IsA("Model") and isAutoValid(obj) then
            table.insert(list, obj)
        end
    end
    return list
end

local function isTouchingTarget(target)
    local _, hrp = getHumanoidAndHRP()
    if not hrp or not target then return false end
    local targetPart = target:FindFirstChild("HumanoidRootPart") or target.PrimaryPart or target:FindFirstChildWhichIsA("BasePart")
    if not targetPart then return false end
    return (hrp.Position - targetPart.Position).Magnitude <= 6
end

local function teleportToNext()
    local _, hrp = getHumanoidAndHRP()
    if not hrp then return end

    -- clean visited
    for m in pairs(visitedModels) do
        if not m:IsDescendantOf(workspace) then
            visitedModels[m] = nil
        end
    end

    local allTargets = findTargets()
    local available = {}
    for _, m in ipairs(allTargets) do
        if not visitedModels[m] then table.insert(available, m) end
    end

    if #available == 0 then
        table.clear(visitedModels)
        return
    end

    table.sort(available, function(a,b)
        return (hrp.Position - getModelCFrame(a).Position).Magnitude < (hrp.Position - getModelCFrame(b).Position).Magnitude
    end)

    currentTarget = available[1]
    if currentTarget then
        local cf = getModelCFrame(currentTarget)
        if cf then
            local pos = cf.Position
            if pos.Y < -10 then pos = Vector3.new(pos.X, HeightSafe, pos.Z) end
            hrp.CFrame = CFrame.new(pos + Vector3.new(0,3,0))
        end
    end
end

task.spawn(function()
    while task.wait(ScanInterval) do
        if autoTeleport and LocalPlayer.Character then
            if currentTarget and not currentTarget:IsDescendantOf(workspace) then
                currentTarget = nil
                task.wait(TeleportDelay)
                teleportToNext()
            elseif currentTarget and isTouchingTarget(currentTarget) then
                visitedModels[currentTarget] = true
                task.wait(TeleportDelay)
                teleportToNext()
            elseif not currentTarget then
                teleportToNext()
            end
        end
    end
end)

Tabs.Event:AddToggle("AutoFarmSukkars", {
    Title = "Auto Farm Sukkars",
    Default = false,
    Callback = function(state)
        autoTeleport = state
        if not state then
            currentTarget = nil
            table.clear(visitedModels)
        end
    end,
})


-- Tabs.Custom

local HttpService = game:GetService("HttpService")
local SaveFile = "TuTienData.json"

local Levels = {
    {name = "PhÃ m NhÃ¢n", time = 0, hasStage = false},
    {name = "Káº¿t Äan", time = 10800, hasStage = true},
    {name = "Luyá»‡n KhÃ­", time = 21600, hasStage = true},
    {name = "TrÃºc CÆ¡", time = 32400, hasStage = true},
    {name = "Kim Äan", time = 43200, hasStage = true},
    {name = "NguyÃªn Anh", time = 54000, hasStage = true},
    {name = "HÃ³a Tháº§n", time = 64800, hasStage = true},
    {name = "Luyá»‡n HÆ°", time = 75600, hasStage = true},
    {name = "Há»£p Thá»ƒ", time = 86400, hasStage = true},
    {name = "Äáº¡i Thá»«a", time = 97200, hasStage = true},
    {name = "Äá»™ Kiáº¿p", time = 108000, hasStage = true},
    {name = "ThÃ¡nh Cáº£nh", time = 118800, hasStage = true},
    {name = "ThÃ¡nh VÆ°Æ¡ng", time = 129600, hasStage = true},
    {name = "ChÃ­ TÃ´n", time = 140400, hasStage = true},
    {name = "Chuáº©n Äáº¿", time = 151200, hasStage = true},
    {name = "Äáº¡i Äáº¿", time = 162000, hasStage = true},
}

local Stages = {
    "Nháº¥t Giai",
    "Nhá»‹ Giai",
    "Tam Giai",
    "Tá»© Giai",
    "NgÅ© Giai",
    "Lá»¥c Giai",
    "Tháº¥t Giai",
    "BÃ¡t Giai",
    "Cá»­u Giai"
}

local function LoadData()
    if isfile and isfile(SaveFile) then
        local success, decoded = pcall(function()
            return HttpService:JSONDecode(readfile(SaveFile))
        end)
        if success and decoded then return decoded end
    end
    return {totalTime = 0}
end

local function SaveData(data)
    if writefile then
        writefile(SaveFile, HttpService:JSONEncode(data))
    end
end

local function GetProgress(totalTime)
    for i = #Levels, 1, -1 do
        if totalTime >= Levels[i].time then
            local current = Levels[i]
            local nextLevel = Levels[i + 1]

            if not nextLevel then
                return current.name, (current.hasStage and "Cá»­u Giai" or nil), 1, 1
            end

            local levelDuration = 10800 -- 3h
            local elapsedInLevel = totalTime - current.time
            local percent = math.clamp(elapsedInLevel / levelDuration, 0, 1)

            local stageName, breakthroughPercent
            if current.hasStage then
                local elapsedInStage = elapsedInLevel % 1200
                local stageIndex = math.clamp(math.floor(elapsedInLevel / 1200) + 1, 1, #Stages)
                stageName = Stages[stageIndex]
                breakthroughPercent = math.clamp(elapsedInStage / 1200, 0, 1)
            else
                breakthroughPercent = 0
            end

            return current.name, stageName, percent, breakthroughPercent
        end
    end
    return "PhÃ m NhÃ¢n", nil, 0, 0
end

local Data = LoadData()

local Paragraph = Tabs.Custom:AddParagraph({
    Title = "ThÃ´ng Tin",
    Content = "Äang khá»Ÿi Ä‘á»™ng..."
})

task.spawn(function()
    while task.wait(1) do
        Data.totalTime += 1
        local level, stage, percent, breakP = GetProgress(Data.totalTime)

        local content = string.format("Tu Vi: %s\n", level)
        if stage then
            content ..= string.format("Táº§ng: %s\n", stage)
        end
        content ..= string.format("Linh KhÃ­: %.1f%%\n", percent * 100)

        if stage then
            content ..= string.format("Äá»™t PhÃ¡: %.1f%%", breakP * 100)
        end

        Paragraph:SetDesc(content)

        if Data.totalTime % 10 == 0 then
            SaveData(Data)
        end

        if level == "Äáº¡i Äáº¿" and percent >= 1 then
            Paragraph:SetDesc("Tu Vi: Äáº¡i Äáº¿\nTáº§ng: Cá»­u Giai\nLinh KhÃ­: 100%\nÄá»™t PhÃ¡: 100%")
            break
        end
    end
end)


    Tabs.Custom:AddSection("â†³ Animation")

do
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")

    local player = Players.LocalPlayer

    local sprintModule
    pcall(function()
        sprintModule = require(ReplicatedStorage:WaitForChild("Systems").Character.Game.Sprinting)
    end)

    local KillersData = {
        ["Survivors"] = {
            ["Default"] = {
                Idle = "rbxassetid://134624270247120",
                Walk = "rbxassetid://132377038617766",
                Run  = "rbxassetid://115946474977409",
            }
        },
        ["Shasher"] = {
            ["Default"] = {
                Idle = "rbxassetid://116050994905421",
                Walk = "rbxassetid://93622022596108",
                Run  = "rbxassetid://93054787145505",
            },
            ["Pursuer"] = {
                Idle = "rbxassetid://94895464960972",
                Walk = "rbxassetid://100206079439305",
                Run  = "rbxassetid://138660433982140",
            },
            ["subject_0"] = {
                Idle = "rbxassetid://14301056458",
                Walk = "rbxassetid://122325883800612",
                Run  = "rbxassetid://97248175252805",
            }
        },
        ["Coolkidd"] = {
            ["Default"] = {
                Idle = "rbxassetid://18885903667",
                Walk = "rbxassetid://18885906143",
                Run  = "rbxassetid://96571077893813",
            }
        },
        ["John Doe"] = {
            ["Default"] = {
                Idle = "rbxassetid://105880087711722",
                Walk = "rbxassetid://81193817424328",
                Run  = "rbxassetid://132653655520682",
            },
            ["Shadow"] = {
                Idle = "rbxassetid://00000000001",
                Walk = "rbxassetid://00000000002",
                Run  = "rbxassetid://00000000003",
            }
        },
        ["Noli"] = {
            ["Default"] = {
                Idle = "rbxassetid://93841120533318",
                Walk = "rbxassetid://109700476007435",
                Run  = "rbxassetid://117451341682452",
            }
        },
        ["1x1x1x1"] = {
            ["Default"] = {
                Idle = "rbxassetid://138754221537146",
                Walk = "rbxassetid://131235528875091",
                Run  = "rbxassetid://106485518413331",
            },
            ["Hacklord [Old]"] = {
                Idle = "rbxassetid://82241652784826",
                Walk = "rbxassetid://119242164490314",
                Run  = "rbxassetid://92430101129682",
            },
            ["Hacklord [New]"] = {
                Idle = "rbxassetid://106131211773069",
                Walk = "rbxassetid://119112338263474",
                Run  = "rbxassetid://85339002634979",
            }
        },
        ["Herobrine"] = {
            ["Default"] = {
                Idle = "rbxassetid://107799240559806",
                Walk = "rbxassetid://89380107485006",
                Run  = "rbxassetid://134157363854022",
            }
        },
        ["Gubby"] = {
            ["Default"] = {
                Idle = "rbxassetid://88333702239259",
                Walk = "rbxassetid://115244584291581",
                Run  = "rbxassetid://115244584291581",
            }
        },
        ["Sancho"] = {
            ["Default"] = {
                Idle = "rbxassetid://115073581864188",
                Walk = "rbxassetid://95213748170889",
                Run  = "rbxassetid://75409814098993",
            }
        },
        ["Erlking"] = {
            ["Default"] = {
                Idle = "rbxassetid://93727662665079",
                Walk = "rbxassetid://97625643261790",
                Run  = "rbxassetid://119357938208454",
            }
        },
        ["Sukuna"] = {
            ["Default"] = {
                Idle = "rbxassetid://115268929362938",
                Walk = "rbxassetid://123678890237669",
                Run  = "rbxassetid://132086389849889",
                Music = "rbxassetid://73595818073606"
            }
        }
    }

    local enabled = false
    local selectedKiller = "Shasher"
    local selectedSkin = "Default"
    local character, humanoid, animator
    local idleAnim, walkAnim, runAnim
    local idleTrack, walkTrack, runTrack
    local _isSprinting = false
    local musicSound

    local runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn = nil, nil, nil, nil, nil
    local heartbeatAccumulator = 0
    local HEARTBEAT_CHECK_INTERVAL = 0.12

    local function stopAndClearTracks()
        for _, track in ipairs({idleTrack, walkTrack, runTrack}) do
            if track then pcall(function() track:Stop() end) end
        end
        idleTrack, walkTrack, runTrack = nil, nil, nil
    end

    local function stopMusic()
        if musicSound then
            pcall(function()
                musicSound:Stop()
                musicSound:Destroy()
            end)
            musicSound = nil
        end
    end

    local function playMusicIfSukuna(set)
        stopMusic()
        if selectedKiller == "Sukuna" and set and set.Music then
            local sound = Instance.new("Sound")
            sound.SoundId = set.Music
            sound.Looped = true
            sound.Volume = 2
            sound.Parent = workspace
            sound:Play()
            musicSound = sound
        end
    end

    local function disconnectListeners()
        for _, c in ipairs({runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn}) do
            if c then pcall(function() c:Disconnect() end) end
        end
        runningConn, heartbeatConn, characterRemovingConn, inputBeganConn, inputEndedConn = nil, nil, nil, nil, nil
    end

    local function cleanupCurrentCharacter()
        stopAndClearTracks()
        stopMusic()
        disconnectListeners()
        animator, humanoid, character = nil, nil, nil
    end

    local function loadAnimObjects(killer, skin)
        local killerTable = KillersData[killer]
        if not killerTable then
            warn("loadAnimObjects: killer khÃ´ng tá»“n táº¡i:", tostring(killer))
            return
        end
        local set = killerTable[skin or "Default"] or killerTable["Default"]
        if not set then return end

        idleAnim, walkAnim, runAnim = Instance.new("Animation"), Instance.new("Animation"), Instance.new("Animation")
        idleAnim.Name, walkAnim.Name, runAnim.Name = "IdleAnim", "WalkAnim", "RunAnim"
        idleAnim.AnimationId, walkAnim.AnimationId, runAnim.AnimationId = set.Idle, set.Walk, set.Run

        playMusicIfSukuna(set)
    end

    local function playAnim(animObj, trackType)
        if not animator then return end

        if trackType ~= "Idle" and idleTrack then pcall(function() idleTrack:Stop() end) idleTrack=nil end
        if trackType ~= "Walk" and walkTrack then pcall(function() walkTrack:Stop() end) walkTrack=nil end
        if trackType ~= "Run" and runTrack then pcall(function() runTrack:Stop() end) runTrack=nil end

        local track
        if trackType=="Idle" and not idleTrack then idleTrack = animator:LoadAnimation(idleAnim) track=idleTrack
        elseif trackType=="Walk" and not walkTrack then walkTrack = animator:LoadAnimation(walkAnim) track=walkTrack
        elseif trackType=="Run" and not runTrack then runTrack = animator:LoadAnimation(runAnim) track=runTrack
        else track = (trackType=="Idle" and idleTrack) or (trackType=="Walk" and walkTrack) or runTrack end

        if track and not track.IsPlaying then pcall(function() track:Play() end) end
    end

    local function playIdle() playAnim(idleAnim,"Idle") end
    local function playWalk() playAnim(walkAnim,"Walk") end
    local function playRun() playAnim(runAnim,"Run") end

    local function updateMovementState()
        if not enabled or not character then return end
        local moving=false
        if humanoid and humanoid.MoveDirection then
            moving = humanoid.MoveDirection.Magnitude>0
            if not moving then
                local root = character:FindFirstChild("HumanoidRootPart") or character.PrimaryPart
                if root and root.Velocity.Magnitude>1 then moving=true end
            end
        end
        if moving then
            local sprintingNow = (sprintModule and sprintModule.IsSprinting) or _isSprinting
            if sprintingNow then playRun() else playWalk() end
        else
            playIdle()
        end
    end

    local function setupMovementListeners()
        disconnectListeners()
        inputBeganConn = UserInputService.InputBegan:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=true end end)
        inputEndedConn = UserInputService.InputEnded:Connect(function(input,gp) if gp then return end if input.KeyCode==Enum.KeyCode.LeftShift then _isSprinting=false end end)

        if humanoid and humanoid.Running then
            runningConn = humanoid.Running:Connect(function(speed) if not enabled then return end if speed>0 then updateMovementState() else playIdle() end end)
        else
            heartbeatAccumulator=0
            heartbeatConn = RunService.Heartbeat:Connect(function(dt)
                if not enabled or not character then return end
                heartbeatAccumulator+=dt
                if heartbeatAccumulator>=HEARTBEAT_CHECK_INTERVAL then
                    heartbeatAccumulator=0
                    updateMovementState()
                end
            end)
        end
    end

    local function onCharacterBound(char)
        cleanupCurrentCharacter()
        character=char
        humanoid=char:FindFirstChildOfClass("Humanoid") or char:FindFirstChildOfClass("AnimationController")
        if humanoid then
            animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
        end
        characterRemovingConn = char.AncestryChanged:Connect(function(_,parent) if not parent then cleanupCurrentCharacter() end end)
        if enabled then
            loadAnimObjects(selectedKiller, selectedSkin)
            setupMovementListeners()
            updateMovementState()
        end
    end

    player.CharacterAdded:Connect(onCharacterBound)
    if player.Character then onCharacterBound(player.Character) end

    local killerNames = {}
    for name,_ in pairs(KillersData) do table.insert(killerNames, name) end
    table.sort(killerNames)

    local SkinDropdown -- khai bÃ¡o trÆ°á»›c

    local killerDropdown = Tabs.Custom:AddDropdown("ChooseKillersDropdown", {
        Title = "Choose Killers",
        Values = killerNames,
        Default = selectedKiller,
        Multi = false,
        Callback = function(value)
            local ok, err = pcall(function()
                selectedKiller = value
                selectedSkin = "Default"

                local skins = {}
                local t = KillersData[selectedKiller] or {}
                for sName,_ in pairs(t) do table.insert(skins, sName) end
                if #skins == 0 then skins = {"Default"} end
                table.sort(skins)

                if SkinDropdown and type(SkinDropdown.SetValues)=="function" and type(SkinDropdown.SetValue)=="function" then
                    SkinDropdown:SetValues(skins)
                    pcall(function() SkinDropdown:SetValue(skins[1] or "Default") end)
                end

                if enabled and player.Character then
                    loadAnimObjects(selectedKiller, selectedSkin)
                    stopAndClearTracks()
                    updateMovementState()
                else
                    stopMusic()
                end
            end)
            if not ok then warn("ChooseKillersDropdown callback error:", err) end
        end
    })

    SkinDropdown = Tabs.Custom:AddDropdown("ChooseSkinDropdown", {
        Title = "Choose Skin",
        Values = {"Default"},
        Default = "Default",
        Multi = false,
        Callback = function(value)
            local ok, err = pcall(function()
                selectedSkin = value
                if enabled and player.Character then
                    loadAnimObjects(selectedKiller, selectedSkin)
                    stopAndClearTracks()
                    updateMovementState()
                else
                    stopMusic()
                end
            end)
            if not ok then warn("SkinDropdown callback error:", err) end
        end
    })

    Tabs.Custom:AddToggle("FakeKillersToggle", {
        Title = "Fake Killers",
        Default = false,
        Callback = function(state)
            local ok, err = pcall(function()
                enabled = state
                if enabled then
                    if player.Character then
                        loadAnimObjects(selectedKiller, selectedSkin)
                        onCharacterBound(player.Character)
                    end
                else
                    stopAndClearTracks()
                    disconnectListeners()
                    stopMusic()
                end
            end)
            if not ok then warn("FakeKillersToggle callback error:", err) end
        end
    })
end


    Tabs.Custom:AddSection("â†³ Skill")

local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")

local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local BUTTON_SIZE = 48
local FramesLocked = true
local createdFrames = {}

local function makeDraggable(frame)
    local dragging, dragStart, startPos

    frame.InputBegan:Connect(function(input)
        if not FramesLocked and (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
            dragging = true
            dragStart = input.Position
            startPos = frame.Position

            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then dragging = false end
            end)
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if dragging and not FramesLocked and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
            local d = input.Position - dragStart
            frame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + d.X, startPos.Y.Scale, startPos.Y.Offset + d.Y)
        end
    end)
end

local function createGui(name)
    local g = Instance.new("ScreenGui")
    g.Name = name
    g.Enabled = false
    g.ResetOnSpawn = false
    g.IgnoreGuiInset = true
    g.Parent = playerGui
    return g
end

local function createButton(gui, data, pos)
    local frame = Instance.new("Frame")
    frame.Name = data.Name .. "_Frame"
    frame.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
    frame.Position = pos
    frame.BackgroundTransparency = 1
    frame.Parent = gui
    frame.Active = true

    Instance.new("UICorner", frame).CornerRadius = UDim.new(1, 0)

    local btn = Instance.new("ImageButton")
    btn.Name = data.Name
    btn.Image = "rbxassetid://" .. data.ImageId
    btn.BackgroundTransparency = 1
    btn.Size = UDim2.new(1, 0, 1, 0)
    btn.ScaleType = Enum.ScaleType.Fit
    btn.Parent = frame
    Instance.new("UICorner", btn).CornerRadius = UDim.new(1, 0)

    btn.MouseButton1Click:Connect(function()
        if not FramesLocked then return end

        local char = player.Character or player.CharacterAdded:Wait()
        local humanoid = char:FindFirstChildOfClass("Humanoid")
        if not humanoid then return end

        local animator = humanoid:FindFirstChildOfClass("Animator") or Instance.new("Animator", humanoid)
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://" .. data.AnimationId
        animator:LoadAnimation(anim):Play()

        if data.PlayMusic and data.MusicId then
            local s = Instance.new("Sound")
            s.SoundId = "rbxassetid://" .. data.MusicId
            s.Parent = char:FindFirstChild("Head") or playerGui
            s.Volume = 1
            s:Play()
            s.Ended:Connect(function() s:Destroy() end)
        end
    end)

    makeDraggable(frame)

    btn.Visible = FramesLocked
    frame.BackgroundTransparency = FramesLocked and 1 or 0.3

    table.insert(createdFrames, frame)
end

local function loadButtonGroup(config)
    local gui = createGui(config.GuiName)

    for i, d in ipairs(config.Buttons) do
        createButton(gui, d, config.Positions[i])
    end

    Tabs.Custom:AddToggle(config.ToggleName, {
        Title = config.DisplayName,
        Default = false
    }):OnChanged(function(v)
        gui.Enabled = v
    end)

    Tabs.Custom:AddToggle(config.LockToggle, {
        Title = "Lock Buttons",
        Default = true
    }):OnChanged(function(v)
        FramesLocked = v
        for _, frame in ipairs(createdFrames) do
            local b = frame:FindFirstChildOfClass("ImageButton")
            if b then b.Visible = v end
            frame.BackgroundTransparency = v and 1 or 0.3
        end
    end)

    Tabs.Custom:AddInput(config.SizeInput, {
        Title = "Button Size",
        Default = tostring(BUTTON_SIZE),
        Numeric = true,
        Finished = true
    }):OnChanged(function(value)
        local num = tonumber(value)
        if num and num > 0 then
            BUTTON_SIZE = num
            for _, frame in ipairs(createdFrames) do
                frame.Size = UDim2.new(0, BUTTON_SIZE, 0, BUTTON_SIZE)
                local btn = frame:FindFirstChildOfClass("ImageButton")
                if btn then btn.Size = UDim2.new(1, 0, 1, 0) end
            end
        end
    end)
end

loadButtonGroup({
    GuiName = "SukunaGUI",
    ToggleName = "SukunaSkill",
    DisplayName = "Sukuna Skill",
    LockToggle = "SukunaLock",
    SizeInput = "SukunaSize",

    Buttons = {
        {Name="Btn1", AnimationId="135853087227453", PlayMusic=true, MusicId="81361259756089", ImageId="134210378382767"},
        {Name="Btn2", AnimationId="99784586201997",  PlayMusic=false, ImageId="134210378382767"},
        {Name="Btn3", AnimationId="121162477402224", PlayMusic=true, MusicId="120185817748858", ImageId="85785826985052"},
        {Name="Btn4", AnimationId="101816924844805", PlayMusic=true, MusicId="88406027536494", ImageId="85785826985052"}
    },

    Positions = {
        UDim2.new(0,80,0,200),
        UDim2.new(0,140,0,200),
        UDim2.new(0,200,0,200),
        UDim2.new(0,260,0,200),
    }
})


loadButtonGroup({
    GuiName = "Guest1337GUI",
    ToggleName = "GuestSkill",
    DisplayName = "Guest1337 Skill",
    LockToggle = "Guest1337Lock",
    SizeInput = "Guest1337Size",

    Buttons = {
        {Name="Btn1", AnimationId="72722244508749", PlayMusic=false, ImageId="87293861183080"},
        {Name="Btn2", AnimationId="96959123077498", PlayMusic=false, ImageId="87293861183080"},
        {Name="Btn3", AnimationId="87259391926321", PlayMusic=false, ImageId="87293861183080"}
    },

    Positions = {
        UDim2.new(0,80,0,200),
        UDim2.new(0,140,0,200),
        UDim2.new(0,200,0,200),
    }
})


-- Tabs.Player


local ActiveNoStun = false
local noStunLoop

Tabs.Player:AddToggle("NoStunToggle", {
    Title = "No Stun",
    Default = false,
}):OnChanged(function(value)
    ActiveNoStun = value

    if value then
        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end

        noStunLoop = task.spawn(function()
            while ActiveNoStun do
                local character = game.Players.LocalPlayer.Character
                local hrp = character and character:FindFirstChild("HumanoidRootPart")
                if hrp then
                    hrp.Anchored = false
                end
                task.wait(0.1)
            end
        end)
    else

        if noStunLoop then
            task.cancel(noStunLoop)
            noStunLoop = nil
        end
    end
end)






local InfStaminaEnabled = false  
local staminaLoop  
local StaminaModule  
pcall(function()  
    local ReplicatedStorage = game:GetService("ReplicatedStorage")  
    local path = ReplicatedStorage:FindFirstChild("Systems")  
        and ReplicatedStorage.Systems:FindFirstChild("Character")  
        and ReplicatedStorage.Systems.Character:FindFirstChild("Game")  
        and ReplicatedStorage.Systems.Character.Game:FindFirstChild("Sprinting")  
    if path then  
        StaminaModule = require(path)  
    end  
end)  
-- HÃ m há»“i stamina an toÃ n  
local function restoreStamina()  
    if not StaminaModule then return end  
    local maxStamina = StaminaModule.MaxStamina or 100  
    if StaminaModule.Stamina then  
        if typeof(StaminaModule.SetStamina) == "function" then  
            StaminaModule:SetStamina(maxStamina)  
        elseif typeof(StaminaModule.UpdateStamina) == "function" then  
            StaminaModule:UpdateStamina(maxStamina)  
        else  
            StaminaModule.Stamina = maxStamina  
        end  
    end  
end  
if StaminaModule then  
    Tabs.Player:AddToggle("InfStamina", {  
        Title = "Infinite Stamina",  
        Default = false  
    }):OnChanged(function(value)
        local ok = pcall(function()  
            InfStaminaEnabled = value  
            if StaminaModule.StaminaLossDisabled ~= nil then  
                StaminaModule.StaminaLossDisabled = value  
            end  
            if value then  
                restoreStamina()  
                if not staminaLoop then  
                    staminaLoop = task.spawn(function()  
                        while InfStaminaEnabled do  
                            task.wait(0.01)  
                            restoreStamina()  
                        end  
                        staminaLoop = nil  
                    end)  
                end  
            end  
        end)  
    end)  
else  
    warn("[InfStamina] Sprinting module not found, toggle disabled.")  
end




Tabs.Player:AddToggle("InfiniteZoom", {
    Title = "Infinite Zoom",
    Default = false,
    Callback = function(Value)
        local player = game.Players.LocalPlayer
        local camera = workspace.CurrentCamera

        if Value then
            player.CameraMaxZoomDistance = math.huge
            player.CameraMinZoomDistance = 0.5
            print("[ZoomCam] Infinite Zoom Enabled âœ…")
        else
            player.CameraMaxZoomDistance = 128
            player.CameraMinZoomDistance = 0.5
            print("[ZoomCam] Infinite Zoom Disabled âŒ")
        end
    end
})


    Tabs.Player:AddSection("â†³ Hitbox")


repeat task.wait() until game:IsLoaded()

local ForsakenReachEnabled = false
local NearestDist = 120

Tabs.Player:AddToggle("ForsakenReachToggle", {
    Title = "Hitbox Devil",
    Default = false,
    Save = true
}):OnChanged(function(Value)
    ForsakenReachEnabled = Value
end)

Tabs.Player:AddSlider("ForsakenReachSlider", {
    Title = "Distance",
    Default = 120,
    Min = 10,
    Max = 300,
    Rounding = 0,
    Save = true,
    Suffix = " studs"
}):OnChanged(function(Value)
    NearestDist = Value
end)

local Players = game:GetService('Players')
local Player = Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()
local Humanoid = Character:WaitForChild("Humanoid")
local HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")

Player.CharacterAdded:Connect(function(NewCharacter)
    Character = NewCharacter
    Humanoid = Character:WaitForChild("Humanoid")
    HumanoidRootPart = Character:WaitForChild("HumanoidRootPart")
end)

local RNG = Random.new()

local AttackAnimations = {
    'rbxassetid://131430497821198',
    'rbxassetid://83829782357897',
    'rbxassetid://126830014841198',
    'rbxassetid://126355327951215',
    'rbxassetid://121086746534252',
    'rbxassetid://105458270463374',
    'rbxassetid://127172483138092',
    'rbxassetid://18885919947',
    'rbxassetid://18885909645',
    'rbxassetid://87259391926321',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://86545133269813',
    'rbxassetid://89448354637442',
    'rbxassetid://90499469533503',
    'rbxassetid://116618003477002',
    'rbxassetid://106086955212611',
    'rbxassetid://107640065977686',
    'rbxassetid://77124578197357',
    'rbxassetid://101771617803133',
    'rbxassetid://134958187822107',
    'rbxassetid://111313169447787',
    'rbxassetid://71685573690338',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://136007065400978',
    'rbxassetid://136007065400978',
    'rbxassetid://86096387000557',
    'rbxassetid://108807732150251',
    'rbxassetid://138040001965654',
    'rbxassetid://73502073176819',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://129843313690921',
    'rbxassetid://97623143664485',
    'rbxassetid://86709774283672',
    'rbxassetid://106014898528300',
    'rbxassetid://87259391926321',
    'rbxassetid://140703210927645',
    'rbxassetid://96173857867228',
    'rbxassetid://121255898612475',
    'rbxassetid://98031287364865',
    'rbxassetid://119462383658044',
    'rbxassetid://77448521277146',
    'rbxassetid://77448521277146',
    'rbxassetid://103741352379819',
    'rbxassetid://119462383658044',
    'rbxassetid://131696603025265',
    'rbxassetid://122503338277352',
    'rbxassetid://97648548303678',
    'rbxassetid://94162446513587',
    'rbxassetid://84426150435898',
    'rbxassetid://93069721274110',
    'rbxassetid://114620047310688',
    'rbxassetid://97433060861952',
    'rbxassetid://82183356141401',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://100592913030351',
    'rbxassetid://121293883585738',
    'rbxassetid://70447634862911',
    'rbxassetid://92173139187970',
    'rbxassetid://106847695270773',
    'rbxassetid://125403313786645',
    'rbxassetid://81639435858902',
    'rbxassetid://137314737492715',
    'rbxassetid://120112897026015',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://109667959938617',
    'rbxassetid://74707328554358',
    'rbxassetid://133336594357903',
    'rbxassetid://86204001129974',
    'rbxassetid://82113744478546',
    'rbxassetid://118298475669935',
    'rbxassetid://124243639579224',
    'rbxassetid://70371667919898',
    'rbxassetid://131543461321709',
    'rbxassetid://136323728355613',
    'rbxassetid://109230267448394',
    'rbxassetid://139835501033932',
    'rbxassetid://106538427162796',
    'rbxassetid://109667959938617',
    'rbxassetid://126681776859538',
    'rbxassetid://129976080405072',
    'rbxassetid://110400453990786',
    'rbxassetid://83685305553364',
    'rbxassetid://126171487400618',
    'rbxassetid://122709416391891',
    'rbxassetid://87989533095285',
    'rbxassetid://119326397274934',
    'rbxassetid://140365014326125',
    'rbxassetid://139309647473555',
    'rbxassetid://133363345661032',
    'rbxassetid://128414736976503',
    'rbxassetid://121808371053483',
    'rbxassetid://77375846492436',
    'rbxassetid://92445608014276',
    'rbxassetid://100358581940485',
    'rbxassetid://91758760621955',
    'rbxassetid://94634594529334',
    'rbxassetid://101101433684051',
    'rbxassetid://90620531468240',
    'rbxassetid://94958041603347',
    'rbxassetid://131642454238375',
    'rbxassetid://110702884830060',
    'rbxassetid://76312020299624',
    'rbxassetid://126654961540956',
    'rbxassetid://139613699193400',
    'rbxassetid://91509234639766',
    'rbxassetid://105458270463374',
    'rbxassetid://109777684604906'
}

local Killers = {
    ["Slasher"] = true, ["1x1x1x1"] = true, ["c00lkidd"] = true,
    ["Noli"] = true, ["JohnDoe"] = true, ["Guest 666"] = true,
    ["Sixer"] = true
}

local Survivors = {
    ["Noob"] = true, ["Guest1337"] = true, ["Elliot"] = true,
    ["Shedletsky"] = true, ["TwoTime"] = true, ["007n7"] = true,
    ["Chance"] = true, ["Builderman"] = true, ["Taph"] = true,
    ["Dusekkar"] = true, ["Veeronica"] = true
}

local function ForsakenReachLogic()
    if not ForsakenReachEnabled or not HumanoidRootPart then
        return
    end

    local Playing = false
    for _,v in Humanoid:GetPlayingAnimationTracks() do
        if table.find(AttackAnimations, v.Animation.AnimationId) and (v.TimePosition / v.Length < 0.75) then
            Playing = true
        end
    end

    if not Playing then
        return
    end

    local PlayerRole = nil -- "Killer" | "Survivor" | nil
    local myModelName = Character and Character.Name
    if myModelName and Killers[myModelName] then
        PlayerRole = "Killer"
    elseif myModelName and Survivors[myModelName] then
        PlayerRole = "Survivor"
    end

    local OppositeTable = nil
    if PlayerRole == "Killer" then
        OppositeTable = Survivors
    elseif PlayerRole == "Survivor" then
        OppositeTable = Killers
    end

    local Target = nil
    local CurrentNearestDist = NearestDist

    local OppTarget = nil
    local OppNearestDist = NearestDist

    local function loopForOpp(t)
        for _,v in pairs(t) do
            if v == Character or not v:FindFirstChild("HumanoidRootPart") or not v:FindFirstChild("Humanoid") then
                continue
            end
            local modelName = v.Name
            if OppositeTable and OppositeTable[modelName] then
                local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
                if Dist < OppNearestDist then
                    OppNearestDist = Dist
                    OppTarget = v
                end
            end
        end
    end

    if OppositeTable then
        loopForOpp(workspace.Players:GetDescendants())
        local npcsFolder = workspace.Map:FindFirstChild("NPCs", true)
        if npcsFolder then
            loopForOpp(npcsFolder:GetChildren())
        end
    end
    local function loopAll(t)
        for _,v in pairs(t) do
            if v == Character or not v:FindFirstChild("HumanoidRootPart") or not v:FindFirstChild("Humanoid") then
                continue
            end
            local modelName = v.Name
            if PlayerRole == "Killer" and Killers[modelName] then
                continue
            end
            if PlayerRole == "Survivor" and Survivors[modelName] then
                continue
            end
            local Dist = (v.HumanoidRootPart.Position - HumanoidRootPart.Position).Magnitude
            if Dist < CurrentNearestDist then
                CurrentNearestDist = Dist
                Target = v
            end
        end
    end

    local FinalTarget = nil
    if OppTarget then
        FinalTarget = OppTarget
    else
        loopAll(workspace.Players:GetDescendants())
        local npcsFolder2 = workspace.Map:FindFirstChild("NPCs", true)
        if npcsFolder2 then
            loopAll(npcsFolder2:GetChildren())
        end
        FinalTarget = Target
    end

    if not FinalTarget then
        return
    end

    local OldVelocity = HumanoidRootPart.Velocity
    local NeededVelocity =
        (FinalTarget.HumanoidRootPart.Position + Vector3.new(
            RNG:NextNumber(-1.5, 1.5),
            0,
            RNG:NextNumber(-1.5, 1.5)
        ) + (FinalTarget.HumanoidRootPart.Velocity * (Player:GetNetworkPing() * 1.25))
            - HumanoidRootPart.Position
        ) / (Player:GetNetworkPing() * 2)

    HumanoidRootPart.Velocity = NeededVelocity
    game:GetService('RunService').RenderStepped:Wait()
    HumanoidRootPart.Velocity = OldVelocity
end

task.spawn(function()
    while true do
        task.wait(0)
        pcall(ForsakenReachLogic)
    end
end)



local Players = game:GetService("Players")
local RunService = game:GetService("RunService")

local LocalPlayer = Players.LocalPlayer

local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
local Humanoid = Character:FindFirstChildOfClass("Humanoid")
local HRP = Character:FindFirstChild("HumanoidRootPart")

local function onCharacterAdded(char)
    Character = char
    Humanoid = Character:WaitForChild("Humanoid")
    HRP = Character:WaitForChild("HumanoidRootPart")
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

local WalkSpeed = {
    Value = 16,
    Active = false,
    Loop = nil
}

local function setWalkSpeed(speed)
    if Humanoid then
        Humanoid.WalkSpeed = speed
        Humanoid:SetAttribute("BaseSpeed", speed)
    end
end

Tabs.Player:AddSection("â†³ Walk Speed")

Tabs.Player:AddSlider("PlayerSpeedSlider", {
    Title = "Set Speed",
    Min = 0,
    Max = 40,
    Default = WalkSpeed.Value,
    Rounding = 1,
}):OnChanged(function(value)
    WalkSpeed.Value = value
    if WalkSpeed.Active then
        setWalkSpeed(WalkSpeed.Value)
    end
end)

Tabs.Player:AddToggle("PlayerSpeedToggle", {
    Title = "Walk Speed",
    Default = false,
}):OnChanged(function(enabled)
    WalkSpeed.Active = enabled
    if enabled then
        setWalkSpeed(WalkSpeed.Value)
        WalkSpeed.Loop = task.spawn(function()
            while WalkSpeed.Active do
                setWalkSpeed(WalkSpeed.Value)
                task.wait(0.5)
            end
        end)
    else
        WalkSpeed.Loop = nil
        setWalkSpeed(16) -- reset speed
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    task.wait(0.1)
    if WalkSpeed.Active then
        setWalkSpeed(WalkSpeed.Value)
    end
end)

local TeleportSpeed = {
    Value = 50,
    Max = 300,
    Active = false
}

Tabs.Player:AddSection("â†³ Teleport Speed")

Tabs.Player:AddSlider("TeleportSpeedSlider", {
    Title = "Set Speed",
    Min = 1,
    Max = TeleportSpeed.Max,
    Default = TeleportSpeed.Value,
    Rounding = 1,
}):OnChanged(function(value)
    TeleportSpeed.Value = value
end)

Tabs.Player:AddToggle("TeleportSpeedToggle", {
    Title = "Teleport Speed",
    Default = false,
}):OnChanged(function(enabled)
    TeleportSpeed.Active = enabled
end)

RunService.Heartbeat:Connect(function(dt)
    if TeleportSpeed.Active and Humanoid and HRP then
        if Humanoid.MoveDirection.Magnitude > 0 then
            HRP.CFrame = HRP.CFrame + Humanoid.MoveDirection.Unit * (TeleportSpeed.Value * dt)
        end
    end
end)


     

-- Tabs.Visual

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer


local allowedModelsClone = {
    ["1x1x1x1Zombie"] = true,
    ["PizzaDeliveryRig"] = true,
    ["Mafia1"] = true,
    ["Mafia2"] = true,
    ["Mafia3"] = true,
    ["Mafia4"] = true,
}

_G.ESPManager:RegisterType("Clone", Color3.fromRGB(0, 255, 0), function(obj)
    return obj:IsA("Model") and allowedModelsClone[obj.Name]
end, false)

Tabs.Visual:AddToggle("ESPCloneToggle", {
    Title = "ESP Clone",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Clone", state)
end)


    Tabs.Visual:AddSection("â†³ Player")

_G.ESPManager:RegisterType("Player", Color3.fromRGB(0, 255, 255), function(obj)
    local plr = Players:GetPlayerFromCharacter(obj)
    return plr and plr ~= LocalPlayer
end, false)

Tabs.Visual:AddToggle("ESPPlayerToggle", {
    Title = "ESP Player",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Player", state)
end)



local survivorsFolder = workspace:WaitForChild("Players"):WaitForChild("Survivors")
_G.ESPManager:RegisterType("Survivor", Color3.fromRGB(255, 255, 255), function(obj)
    return obj:IsA("Model") and obj.Parent == survivorsFolder and obj:FindFirstChildOfClass("Humanoid")
end, true)

Tabs.Visual:AddToggle("ESPModelWhiteToggle", {
    Title = "ESP Survivors",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Survivor", state)
end)



local killersFolder = workspace:WaitForChild("Players"):WaitForChild("Killers")
_G.ESPManager:RegisterType("Killer", Color3.fromRGB(255, 0, 0), function(obj)
    return obj:IsA("Model") and obj.Parent == killersFolder and obj:FindFirstChildOfClass("Humanoid")
end, true)

Tabs.Visual:AddToggle("ESPModelRedToggle", {
    Title = "ESP Killers",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Killer", state)
end)



    Tabs.Visual:AddSection("â†³ Other")

_G.ESPManager:RegisterType("Generator", Color3.fromRGB(255,255,255), function(obj)
    if not (obj and obj:IsA("Model") and obj.Name == "Generator") then
        return false
    end

    local progress = obj:FindFirstChild("Progress", true)
    if not progress or not progress:IsA("NumberValue") then
        return false
    end

    if not progress:GetAttribute("ESP_Watch") then
        progress:SetAttribute("ESP_Watch", true)
        progress:GetPropertyChangedSignal("Value"):Connect(function()
            -- Náº¿u Ä‘áº¡t 100% thÃ¬ remove ESP ngay
            if progress.Value >= 100 then
                _G.ESPManager:Remove(obj)
            else
                -- Náº¿u ESP chÆ°a cÃ³, táº¡o láº¡i
                if not _G.ESPManager.Objects[obj] then
                    _G.ESPManager:_ScheduleCreate(obj, "Generator")
                end
            end
        end)
    end

    return progress.Value < 100
end, false)

Tabs.Visual:AddToggle("ESPGeneratorToggle", {
    Title = "ESP Generator",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Generator", state)
end)


_G.ESPManager:RegisterType("Item", Color3.fromRGB(255,215,0), function(obj)
    return obj:IsA("Tool") and obj.Parent and obj:IsDescendantOf(workspace:FindFirstChild("Map"))
end, false)

Tabs.Visual:AddToggle("ESPItemsToggle", {
    Title = "ESP Items",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Item", state)
end)


_G.ESPManager:RegisterType("Dispenser", Color3.fromRGB(0, 162, 255), function(obj)
    return obj:IsA("Model") and obj.Name:lower():find("dispenser")
end, false)

_G.ESPManager:RegisterType("Sentry", Color3.fromRGB(128, 128, 128), function(obj)
    return obj:IsA("Model") and obj.Name:lower():find("sentry")
end, false)

_G.ESPManager:RegisterType("Tripwire", Color3.fromRGB(255, 85, 0), function(obj)
    return obj:IsA("Model") and obj.Name:find("TaphTripwire")
end, false)

_G.ESPManager:RegisterType("Subspace", Color3.fromRGB(160, 32, 240), function(obj)
    return obj:IsA("Model") and obj.Name == "SubspaceTripmine"
end, false)

Tabs.Visual:AddSection("â†³ Buildman")

Tabs.Visual:AddToggle("DispenserESP_Toggle", {
    Title = "ESP Dispenser",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Dispenser", state)
end)

Tabs.Visual:AddToggle("SentryESP_Toggle", {
    Title = "ESP Sentry",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Sentry", state)
end)

Tabs.Visual:AddSection("â†³ Tapt/Trap")

Tabs.Visual:AddToggle("TripwireESP_Toggle", {
    Title = "ESP Trip Wire",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Tripwire", state)
end)

Tabs.Visual:AddToggle("SubspaceESP_Toggle", {
    Title = "ESP Bomb Trap",
    Default = false,
}):OnChanged(function(state)
    _G.ESPManager:SetEnabled("Subspace", state)
end)

-- Tabs.Misc

local Lighting = game:GetService("Lighting")
local RunService = game:GetService("RunService")

local fullBrightEnabled = false
local fullBrightLoop

local function applyFullBright()
    if not fullBrightEnabled then return end

    Lighting.Ambient = Color3.fromRGB(200, 200, 200) -- sÃ¡ng nháº¹
    Lighting.Brightness = 4 -- giáº£m Ä‘á»™ sÃ¡ng tá»« 10 â†’ 4
    Lighting.GlobalShadows = false
end

local function enableFullBright()
    if fullBrightLoop then fullBrightLoop:Disconnect() end
    applyFullBright()
    fullBrightLoop = Lighting:GetPropertyChangedSignal("ClockTime"):Connect(applyFullBright)
end

local function disableFullBright()
    if fullBrightLoop then
        fullBrightLoop:Disconnect()
        fullBrightLoop = nil
    end

    Lighting.Ambient = Color3.fromRGB(128, 128, 128)
    Lighting.Brightness = 1
    Lighting.GlobalShadows = true
end

local FbToggle = Tabs.Misc:AddToggle("FbToggle", {
    Title = "Auto Full Bright",
    Default = false
})
FbToggle:OnChanged(function(Value)
    fullBrightEnabled = Value
    if fullBrightEnabled then
        enableFullBright()
    else
        disableFullBright()
    end
end)

local fogEnabled = false
local fogLoop

local function removeFog()
    Lighting.FogStart = 0
    Lighting.FogEnd = 1000000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0
        atmosphere.Offset = 0
        atmosphere.Haze = 0
        atmosphere.Color = Color3.new(1, 1, 1)
    end
end

local function restoreFog()
    Lighting.FogStart = 200
    Lighting.FogEnd = 1000

    local atmosphere = Lighting:FindFirstChild("Atmosphere")
    if atmosphere then
        atmosphere.Density = 0.3
        atmosphere.Offset = 0
        atmosphere.Haze = 0.5
        atmosphere.Color = Color3.fromRGB(200, 200, 200)
    end
end

local FogToggle = Tabs.Misc:AddToggle("FogToggle", {
    Title = "Remove Fog",
    Default = false
})
FogToggle:OnChanged(function(Value)
    fogEnabled = Value
    if fogEnabled then
        removeFog()
        fogLoop = RunService.Heartbeat:Connect(removeFog)
    else
        if fogLoop then fogLoop:Disconnect() fogLoop = nil end
        restoreFog()
    end
end)



local Lighting = game:GetService("Lighting")
local Players = game:GetService("Players")
local LP = Players.LocalPlayer
local PlayerGui = LP:WaitForChild("PlayerGui")

local ActiveRemoveAll = false

local effectNames = {
    "BlurEffect", "ColorCorrectionEffect", "BloomEffect", "SunRaysEffect", 
    "DepthOfFieldEffect", "ScreenFlash", "HitEffect", "DamageOverlay", 
    "BloodEffect", "Vignette", "BlackScreen", "WhiteScreen", "ShockEffect",
    "Darkness", "JumpScare", "LowHealthOverlay", "Flashbang", "FadeEffect"
}

-- Danh sÃ¡ch class hiá»‡u á»©ng trong Lighting
local effectClasses = {
    "BlurEffect",
    "BloomEffect",
    "SunRaysEffect",
    "DepthOfFieldEffect",
    "ColorCorrectionEffect"
}
local function removeAll()
    for _, obj in pairs(Lighting:GetDescendants()) do
        if table.find(effectNames, obj.Name) or table.find(effectClasses, obj.ClassName) then
            obj:Destroy()
        end
    end

    for _, obj in pairs(PlayerGui:GetDescendants()) do
        if table.find(effectNames, obj.Name) then
            obj:Destroy()
        elseif obj:IsA("ScreenGui") or obj:IsA("BillboardGui") or obj:IsA("SurfaceGui") then
            if obj:FindFirstChildWhichIsA("ImageLabel") or obj:FindFirstChildWhichIsA("Frame") then
                if table.find(effectNames, obj.Name) or obj.Name:lower():find("overlay") or obj.Name:lower():find("effect") then
                    obj:Destroy()
                end
            end
        end
    end

    local temp = PlayerGui:FindFirstChild("TemporaryUI")
    if temp then
        local popup = temp:FindFirstChild("1x1x1x1Popup")
        if popup then
            popup:Destroy()
            warn("[Remover] 1x1x1x1Popup removed")
        end
    end
end

Tabs.Misc:AddToggle("RemoveAllBadStuff", {
    Title = "Remove Effects V2",
    Default = true,
    Callback = function(state)
        ActiveRemoveAll = state
        if state then
            task.spawn(function()
                while ActiveRemoveAll do
                    removeAll()
                    task.wait(0.5)
                end
            end)
        end
    end
})

    Tabs.Misc:AddSection("â†³ Bypass")

local antiAFKCons = {}

if getconnections then
    Tabs.Misc:AddToggle("AntiAFK", {
        Title = "Anti-AFK",
        Default = true
    }):OnChanged(function(state)
        local idleCons = getconnections(game.Players.LocalPlayer.Idled)
        
        if state then
            for _, c in ipairs(idleCons) do
                antiAFKCons[c] = true
                c:Disable()
            end
            print("[AntiAFK] ÄÃ£ báº­t, báº¡n sáº½ khÃ´ng bá»‹ kick AFK.")
        else
            for c,_ in pairs(antiAFKCons) do
                if c and c.Enable then
                    pcall(function() c:Enable() end)
                end
            end
            antiAFKCons = {}
            print("[AntiAFK] ÄÃ£ táº¯t, Roblox sáº½ xá»­ lÃ½ AFK bÃ¬nh thÆ°á»ng.")
        end
    end)
else
    warn("[AntiAFK] Executor khÃ´ng há»— trá»£ getconnections, toggle bá»‹ vÃ´ hiá»‡u.")
end



    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local LocalizationService = game:GetService("LocalizationService")

    shared.AntiBanSafe = shared.AntiBanSafe or {running = false, hooks = {}}
    local data = shared.AntiBanSafe

    local oldNamecall, oldIndex
    local protectionThread

    local function safe(func, ...)
        local ok, res = pcall(func, ...)
        if ok then return res end
    end

    local function disableReportFlags()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "False")
                setfflag("AbuseReportScreenshotPercentage", "0") -- chá»‰nh vá» 0
                setfflag("AbuseReportEnabled", "False")
                setfflag("ReportAbuseMenu", "False")
                setfflag("EnableAbuseReportScreenshot", "False")
                setfflag("AbuseReportVideo", "False")
                setfflag("AbuseReportVideoPercentage", "0")
                setfflag("VideoCaptureEnabled", "False")
                setfflag("RecordVideo", "False")
            end)
        end
    end

    local function setFlagsOn()
        if typeof(setfflag) == "function" then
            pcall(function()
                setfflag("AbuseReportScreenshot", "True")
                setfflag("AbuseReportScreenshotPercentage", "100")
            end)
        end
    end

    local function hookRequests()
        if data.hooks.requestHooked then return end
        local oldRequest = (syn and syn.request) or request or http_request
        if typeof(oldRequest) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldRequest, function(req)
                if req and req.Url and tostring(req.Url):lower():find("abuse") then
                    return {StatusCode = 200, Body = "Blocked"}
                end
                return oldRequest(req)
            end)
            data.hooks.requestHooked = true
        end
    end

    local function hookFindFirstChild()
        if data.hooks.findHooked then return end
        local oldFind = workspace.FindFirstChild
        if typeof(oldFind) == "function" and typeof(hookfunction) == "function" then
            hookfunction(oldFind, function(self, name, ...)
                if name and tostring(name):lower():find("screenshot") then return nil end
                if name and tostring(name):lower():find("video") then return nil end
                return oldFind(self, name, ...)
            end)
            data.hooks.findHooked = true
        end
    end

    local function safeBypass()
        if getrawmetatable and hookmetamethod and newcclosure then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            oldNamecall = oldNamecall or mt.__namecall
            oldIndex = oldIndex or mt.__index

            mt.__namecall = newcclosure(function(self, ...)
                local method = getnamecallmethod()
                local args = {...}

                if (method == "Kick" or method == "Ban") and self == LocalPlayer then return nil end

                if (method == "FireServer" or method == "InvokeServer") and args[1] then
                    local msg = tostring(args[1]):lower()
                    if msg:find("kick") or msg:find("ban") then return nil end
                end

                if self == LocalizationService and method == "GetCountryRegionForPlayerAsync" then
                    local success, result = pcall(function()
                        return LocalizationService:GetCountryRegionForPlayerAsync(LocalPlayer)
                    end)
                    if success then return result else return "US" end
                end

                return oldNamecall(self, ...)
            end)

            mt.__index = newcclosure(function(t, k)
                local key = tostring(k):lower()
                if key:find("kick") or key:find("ban") then return function() return nil end end
                return oldIndex(t, k)
            end)

            setreadonly(mt, true)
        end
    end

    local function restoreHooks()
        if getrawmetatable then
            local mt = getrawmetatable(game)
            setreadonly(mt, false)
            if oldNamecall then mt.__namecall = oldNamecall end
            if oldIndex then mt.__index = oldIndex end
            setreadonly(mt, true)
            oldNamecall, oldIndex = nil, nil
        end
    end

    local function startAntiBanSafe()
        if data.running then return end
        data.running = true

        safe(hookRequests)
        safe(hookFindFirstChild)
        safe(safeBypass)

        protectionThread = task.spawn(function()
            while data.running do
                safe(disableReportFlags)
                task.wait(0.2)
            end
        end)

        print("[Anti-Ban Safe] ðŸ›¡ï¸ ENABLED!")
    end

    local function stopAntiBanSafe()
        data.running = false
        protectionThread = nil
        restoreHooks()
        setFlagsOn() -- phá»¥c há»“i flag vá» bÃ¬nh thÆ°á»ng
        print("[Anti-Ban Safe] âš ï¸ DISABLED!")
    end

    Tabs.Misc:AddToggle("AntiBanV3", {
        Title = "Anti Ban V3.5",
        Default = true,
        Callback = function(state)
            if state then
                startAntiBanSafe()
            else
                stopAntiBanSafe()
            end
        end
    })



    Tabs.Misc:AddSection("â†³ Game Play")

    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Survivors = workspace:WaitForChild("Players"):WaitForChild("Survivors")

    local AntiSlowConfigs = {
        Slowness = {Values = {"SlowedStatus"}, Thread = nil, Enabled = false},
        Skills = {
            Values = {
                "StunningKiller", "EatFriedChicken", "GuestBlocking", "PunchAbility", "SubspaceTripmine",
                "TaphTripwire", "PlasmaBeam", "SpawnProtection", "c00lgui", "ShootingGun", 
                "TwoTimeStab", "TwoTimeCrouching", "DrinkingCola", "DrinkingSlateskin", 
                "SlateskinStatus", "EatingGhostburger"
            },
            Thread = nil, Enabled = false
        },
        Items = {Values = {"BloxyColaItem", "Medkit"}, Thread = nil, Enabled = false},
        Emotes = {Values = {"Emoting"}, Thread = nil, Enabled = false},
        Builderman = {Values = {"DispenserConstruction", "SentryConstruction"}, Thread = nil, Enabled = false}
    }

    local function hideSlownessUI()
        local mainUI = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("MainUI")
        if not mainUI then return end
        local statusContainer = mainUI:FindFirstChild("StatusContainer")
        if not statusContainer then return end
        local slownessUI = statusContainer:FindFirstChild("Slowness")
        if slownessUI then
            slownessUI.Visible = false
        end
    end

    local function startAntiSlow(config)
        config.Thread = task.spawn(function()
            while config.Enabled do
                task.wait(0.5)

                for _, survivor in pairs(Survivors:GetChildren()) do
                    if survivor:GetAttribute("Username") == LocalPlayer.Name then
                        local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
                        if speedMultipliers then
                            for _, valName in ipairs(config.Values) do
                                local val = speedMultipliers:FindFirstChild(valName)
                                if val and val:IsA("NumberValue") and val.Value ~= 1 then
                                    val.Value = 1
                                end
                            end
                        end
                        hideSlownessUI()
                    end
                end
            end
        end)
    end

    local function startAllAntiSlow()
        for _, config in pairs(AntiSlowConfigs) do
            config.Enabled = true
            startAntiSlow(config)
        end
    end

    local function stopAllAntiSlow()
        for _, config in pairs(AntiSlowConfigs) do
            config.Enabled = false
        end
    end

    Tabs.Misc:AddToggle("AntiSlow_All", {
        Title = "Anti-Slow",
        Default = false
    }):OnChanged(function(Value)
        if Value then
            startAllAntiSlow()
        else
            stopAllAntiSlow()
        end
    end)



    local DoLoop = false
    local Players = game:GetService("Players")
    local LocalPlayer = Players.LocalPlayer
    local Workspace = game:GetService("Workspace")

    Tabs.Misc:AddToggle("AutoClosePopupV2", {
        Title = "Detele 1x Popups",
        Default = true
    }):OnChanged(function(Value)
        DoLoop = Value

        task.spawn(function()
            local Survivors = Workspace:WaitForChild("Players"):WaitForChild("Survivors")

            while DoLoop and task.wait(0.5) do  -- â¬… Delay máº·c Ä‘á»‹nh: 0.5s

                local temp = LocalPlayer:FindFirstChild("PlayerGui") and LocalPlayer.PlayerGui:FindFirstChild("TemporaryUI")
                if temp and temp:FindFirstChild("1x1x1x1Popup") then
                    temp["1x1x1x1Popup"]:Destroy()
                end

                for _, survivor in pairs(Survivors:GetChildren()) do
                    if survivor:GetAttribute("Username") == LocalPlayer.Name then
                        -- SpeedMultipliers
                        local speedMultipliers = survivor:FindFirstChild("SpeedMultipliers")
                        if speedMultipliers then
                            local val = speedMultipliers:FindFirstChild("SlowedStatus")
                            if val and val:IsA("NumberValue") then
                                val.Value = 1
                            end
                        end

                        local fovMultipliers = survivor:FindFirstChild("FOVMultipliers")
                        if fovMultipliers then
                            local val = fovMultipliers:FindFirstChild("SlowedStatus")
                            if val and val:IsA("NumberValue") then
                                val.Value = 1
                            end
                        end
                    end
                end
            end
        end)
    end)



    Tabs.Misc:AddSection("â†³ Fix Lag")

local TeleportService = game:GetService("TeleportService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local function ServerHop()
    local placeId = game.PlaceId
    local jobId = game.JobId
    print("[ServerHop] Äang rá»i server hiá»‡n táº¡i...")

    local success, err = pcall(function()
        TeleportService:Teleport(placeId, LocalPlayer)
    end)

    if success then
        if Fluent and Fluent.Notify then
            Fluent:Notify({
                Title = "Rejoin Starting",
                Content = "Báº¯t Äáº§u VÃ o MÃ¡y Chá»§ ÄÃ£ Fix Lag",
                Duration = 3
            })
        else
            print("[ServerHop] Äang chuyá»ƒn server...")
        end
    else
        warn("[ServerHop] Lá»—i khi Teleport:", err)
        if Fluent and Fluent.Notify then
            Fluent:Notify({
                Title = "Lá»—i Teleport",
                Content = tostring(err),
                Duration = 4
            })
        end
    end
end

Tabs.Misc:AddButton({
    Title = "Rejoin To Fix Lag",
    Callback = function()
        if Fluent and Fluent.Notify then
            Fluent:Notify({
                Title = "Rejoin Settings",
                Content = "Äang Giáº£m Lag Cho CÃ¡c MÃ¡y Chá»§...",
                Duration = 2
            })
        end

        task.wait(0.3)
        ServerHop()
    end
})



local originalLighting = {}
local originalParts = {}

local function saveLighting()
    originalLighting.QualityLevel = settings().Rendering.QualityLevel
    originalLighting.GlobalShadows = game.Lighting.GlobalShadows
    originalLighting.FogEnd = game.Lighting.FogEnd
    originalLighting.Brightness = game.Lighting.Brightness
    originalLighting.PostEffects = {}
    for _, v in ipairs(game.Lighting:GetChildren()) do
        if v:IsA("PostEffect") then
            originalLighting.PostEffects[v] = v.Enabled
        end
    end
end

local function restoreLighting()
    if not originalLighting.QualityLevel then return end
    settings().Rendering.QualityLevel = originalLighting.QualityLevel
    game.Lighting.GlobalShadows = originalLighting.GlobalShadows
    game.Lighting.FogEnd = originalLighting.FogEnd
    game.Lighting.Brightness = originalLighting.Brightness
    for effect, state in pairs(originalLighting.PostEffects) do
        if effect and effect.Parent == game.Lighting then
            effect.Enabled = state
        end
    end
end

local function simplifyModel(obj)
    if obj:IsA("BasePart") then
        if not originalParts[obj] then
            originalParts[obj] = {
                Material = obj.Material,
                Color = obj.Color,
                Reflectance = obj.Reflectance,
                CastShadow = obj.CastShadow
            }
        end
        obj.Material = Enum.Material.SmoothPlastic
        obj.Color = Color3.fromRGB(163, 162, 165)
        obj.Reflectance = 0
        obj.CastShadow = false
    elseif obj:IsA("Decal") or obj:IsA("Texture") or obj:IsA("SurfaceAppearance") then
        obj:Destroy()
    elseif obj:IsA("ParticleEmitter") or obj:IsA("Trail") or obj:IsA("Beam") or obj:IsA("Fire") or obj:IsA("Smoke") or obj:IsA("Sparkles") then
        obj.Enabled = false
    end
end

local function restoreParts()
    for part, data in pairs(originalParts) do
        if part and part.Parent then
            part.Material = data.Material
            part.Color = data.Color
            part.Reflectance = data.Reflectance
            part.CastShadow = data.CastShadow
        end
    end
    originalParts = {} -- reset
end

local autoThread
local connection

local AutoReduceToggle = Tabs.Misc:AddToggle("AutoReduce", {
    Title = "FPS Boost",
    Default = false,
    Callback = function(state)
        if state then
            print("ðŸ”„ Auto Reduce ON")

            saveLighting()

            settings().Rendering.QualityLevel = Enum.QualityLevel.Level01
            game.Lighting.GlobalShadows = false
            game.Lighting.FogEnd = 9e9
            game.Lighting.Brightness = 1
            for _, v in ipairs(game.Lighting:GetChildren()) do
                if v:IsA("PostEffect") then
                    v.Enabled = false
                end
            end

            for _, obj in ipairs(workspace:GetDescendants()) do
                simplifyModel(obj)
            end

            connection = workspace.DescendantAdded:Connect(simplifyModel)

            autoThread = task.spawn(function()
                while AutoReduceToggle.Value do
                    task.wait(10)
                    for _, obj in ipairs(workspace:GetDescendants()) do
                        simplifyModel(obj)
                    end
                end
            end)

        else
            print("â¹ Auto Reduce OFF")
            if connection then
                connection:Disconnect()
                connection = nil
            end

            restoreLighting()
            restoreParts()
            print("âœ… ÄÃ£ khÃ´i phá»¥c Ä‘á»“ há»a gá»‘c")
        end
    end
})


local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer

local blockedAnimations = {
    ["127802146383565"] = true,
    ["82691533602949"] = true,
    ["123764169071995"] = true,
}

local BlockAnimEnabled = false
local blockConnections = {}

local function hookHumanoid(humanoid)
    if not humanoid then return end
    local conn = humanoid.AnimationPlayed:Connect(function(track)
        local id = track.Animation.AnimationId:match("%d+")
        if BlockAnimEnabled and blockedAnimations[id] then
            track:Stop()
        end
    end)
    table.insert(blockConnections, conn)
end

local function setBlockAnimations(enabled)
    BlockAnimEnabled = enabled

    for _, conn in pairs(blockConnections) do
        conn:Disconnect()
    end
    table.clear(blockConnections)

    if enabled then

        if LocalPlayer.Character then
            hookHumanoid(LocalPlayer.Character:FindFirstChildWhichIsA("Humanoid"))
        end

        local connChar = LocalPlayer.CharacterAdded:Connect(function(char)
            char:WaitForChild("Humanoid")
            hookHumanoid(char:FindFirstChildWhichIsA("Humanoid"))
        end)
        table.insert(blockConnections, connChar)
    end
end

Tabs.Misc:AddToggle("BlockBadAnims", {
    Title = "Block Animations",
    Default = false
}):OnChanged(function(v)
    setBlockAnimations(v)
end)



    Tabs.Misc:AddSection("â†³ Show")

local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local Camera = workspace.CurrentCamera

local ui = Instance.new("ScreenGui")
ui.Name = "FPS_Ping_Display"
ui.ResetOnSpawn = false
ui.IgnoreGuiInset = true
ui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
ui.Parent = game:GetService("CoreGui")

local fpsLabel = Instance.new("TextLabel")
fpsLabel.Size = UDim2.new(0, 120, 0, 20)
fpsLabel.Position = UDim2.new(1, -130, 0, 5)
fpsLabel.BackgroundTransparency = 1
fpsLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
fpsLabel.TextStrokeTransparency = 0
fpsLabel.TextSize = 16
fpsLabel.Font = Enum.Font.Code
fpsLabel.TextXAlignment = Enum.TextXAlignment.Left
fpsLabel.Text = "FPS: ..."
fpsLabel.Parent = ui

local pingLabel = fpsLabel:Clone()
pingLabel.Position = UDim2.new(1, -130, 0, 25)
pingLabel.Text = "Ping: ..."
pingLabel.Parent = ui

local showFPS = true
local showPing = true
local fpsCounter, lastUpdate = 0, tick()

RunService.RenderStepped:Connect(function()
    fpsCounter += 1
    if tick() - lastUpdate >= 1 then
        if showFPS then
            fpsLabel.Visible = true
            fpsLabel.Text = "FPS: " .. tostring(fpsCounter)
        else
            fpsLabel.Visible = false
        end

        if showPing then
            local pingStat = Stats.Network.ServerStatsItem["Data Ping"]
            local ping = pingStat and math.floor(pingStat:GetValue()) or 0
            pingLabel.Text = "Ping: " .. ping .. " ms"
            if ping <= 60 then
                pingLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
            elseif ping <= 120 then
                pingLabel.TextColor3 = Color3.fromRGB(255, 165, 0)
            else
                pingLabel.TextColor3 = Color3.fromRGB(255, 0, 0)
            end
            pingLabel.Visible = true
        else
            pingLabel.Visible = false
        end

        fpsCounter = 0
        lastUpdate = tick()
    end
end)

local fpsToggle = Tabs.Misc:AddToggle("ShowFPSToggle", {
    Title = "Show FPS",
    Default = true
})
fpsToggle:OnChanged(function(val)
    showFPS = val
    fpsLabel.Visible = val
end)

local pingToggle = Tabs.Misc:AddToggle("ShowPingToggle", {
    Title = "Show Ping",
    Default = true
})
pingToggle:OnChanged(function(val)
    showPing = val
    pingLabel.Visible = val
end)




    getgenv().chatWindow = game:GetService("TextChatService"):WaitForChild("ChatWindowConfiguration")
    getgenv().chatEnabled = false
    getgenv().chatConnection = nil

    Tabs.Misc:AddToggle("ChatVisibilityToggle", {
        Title = "Show Chat",
        Default = false
    }):OnChanged(function(Value)
        getgenv().chatEnabled = Value


        if Value then
            if not getgenv().chatConnection then
                getgenv().chatConnection = game:GetService("RunService").Heartbeat:Connect(function()
                    if getgenv().chatWindow then
                        getgenv().chatWindow.Enabled = true
                    end
                end)
            end
        else

            if getgenv().chatConnection then
                getgenv().chatConnection:Disconnect()
                getgenv().chatConnection = nil
            end
            if getgenv().chatWindow then
                getgenv().chatWindow.Enabled = false
            end
        end
    end)




-- Tabs.Settings


local AexecToggle = Tabs.Settings:AddToggle("AexecToggle", {Title = "Auto Execute", Default = false })
AexecToggle:OnChanged(function(Value)
    if Value then
        task.spawn(function()
            pcall(function()
                if queue_on_teleport then
                    local HutaoHubScript1 = [[
task.wait(3)
loadstring(game:HttpGet("https://raw.githubusercontent.com/hdksakst-ship-it/Hutao-Hub-Omega-X/refs/heads/main/Forsaken-v3.txt"))()
]]
                    queue_on_teleport(HutaoHubScript1)
                end
            end)
        end)
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is enabled!",
            Duration = 5
        })
    else
        Fluent:Notify({
            Title = "Hutao HUB",
            Content = "Auto execute is disabled!",
            Duration = 5
        })
    end
end)

SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

SaveManager:IgnoreThemeSettings()

SaveManager:SetIgnoreIndexes({})

InterfaceManager:SetFolder("Hutao HUB")
SaveManager:SetFolder("Hutao HUB/Forsaken")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)

Window:SelectTab(1)

Fluent:Notify({ Title = "Hutao HUB", Content = "forsaken script loaded successfully!", Duration = 5 })
SaveManager:LoadAutoloadConfig()