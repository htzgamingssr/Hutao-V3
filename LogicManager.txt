local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")

local LocalPlayer = Players.LocalPlayer
local PlayerGui = LocalPlayer:FindFirstChild("PlayerGui")

local survivorsFolder = Workspace:WaitForChild("Players"):WaitForChild("Survivors")
local killersFolder = Workspace:WaitForChild("Players"):WaitForChild("Killers")

local LogicManager = {}

LogicManager.Players = Players
LogicManager.ReplicatedStorage = ReplicatedStorage
LogicManager.Workspace = Workspace

LogicManager.LP = LocalPlayer
LogicManager.PlayerGui = PlayerGui

LogicManager.survivorsFolder = survivorsFolder
LogicManager.killersFolder = killersFolder

function LogicManager.IsSurvivor(obj)
    if not obj then return false end
    local folder = LogicManager.survivorsFolder
    if not folder then return false end

    return obj:IsA("Model")
        and obj.Parent == folder
        and obj:FindFirstChildOfClass("Humanoid")
end

function LogicManager.IsKiller(obj)
    if not obj then return false end
    local folder = LogicManager.killersFolder
    if not folder then return false end

    return obj:IsA("Model")
        and obj.Parent == folder
        and obj:FindFirstChildOfClass("Humanoid")
end

function LogicManager.GetCharacter()
    return LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait()
end

function LogicManager.GetHRP(character)
    character = character or LogicManager.GetCharacter()
    return character and character:FindFirstChild("HumanoidRootPart")
end

_G.LogicManager = LogicManager


getgenv().PizzaSystem = getgenv().PizzaSystem or {}

getgenv().PizzaSystem.AimbotEnabled = getgenv().PizzaSystem.AimbotEnabled or false
getgenv().PizzaSystem.AimDistance   = getgenv().PizzaSystem.AimDistance or 100

getgenv().PizzaSystem.AutoEatEnabled = getgenv().PizzaSystem.AutoEatEnabled or false
getgenv().PizzaSystem.HPThreshold    = getgenv().PizzaSystem.HPThreshold or 30

local RunService = game:GetService("RunService")
local Logic = _G.LogicManager

local PizzaAnimation = {
    ["114155003741146"] = true,
    ["104033348426533"] = true
}

local EliotModels = {["Elliot"] = true}

local autoRotateDisabled = false
local currentTarget, isLockedOn, wasPlayingAnimation = nil, false, false
local aimOffset = 2

local function isEliot()
    local char = Logic.GetCharacter()
    return char and EliotModels[char.Name]
end

local function getMyHumanoid()
    local char = Logic.GetCharacter()
    return char and char:FindFirstChildWhichIsA("Humanoid")
end

local function restoreRotate()
    local hum = getMyHumanoid()
    if hum and autoRotateDisabled then
        hum.AutoRotate = true
        autoRotateDisabled = false
    end
end

local function isPlayingPizzaAttack()
    local hum = getMyHumanoid()
    if not hum then return false end

    local animator = hum:FindFirstChildOfClass("Animator")
    if not animator then return false end

    for _, track in ipairs(animator:GetPlayingAnimationTracks()) do
        local id = tostring(track.Animation.AnimationId):match("%d+")
        if id and PizzaAnimation[id] then return true end
    end
    return false
end

local function getWeakestTarget()
    local list = {}
    local myChar = Logic.GetCharacter()
    local hum = getMyHumanoid()
    local root = Logic.GetHRP(myChar)
    if not root or not hum or hum.MaxHealth <= 0 then return nil end

    local myHp = hum.Health / hum.MaxHealth

    for _, obj in ipairs(Logic.survivorsFolder:GetChildren()) do
        if obj:IsA("Model") and obj ~= myChar then
            local h = obj:FindFirstChildWhichIsA("Humanoid")
            local hrp = Logic.GetHRP(obj)
            if h and hrp and h.Health > 0 then
                local dist = (hrp.Position - root.Position).Magnitude
                if dist <= getgenv().PizzaSystem.AimDistance then
                    table.insert(list, {model=obj, hp=h.Health/h.MaxHealth})
                end
            end
        end
    end

    table.sort(list, function(a,b) return a.hp < b.hp end)
    return list[1] and list[1].model or nil
end

local function getHRP()
    return Logic.GetHRP()
end

local function getHP()
    local hum = getMyHumanoid()
    return hum and hum.Health or 0
end

local function getPizzaCF()
    local map = Logic.Workspace:FindFirstChild("Map")
    local ingame = map and map:FindFirstChild("Ingame")
    if not ingame then return nil end

    local pizza = ingame:FindFirstChild("Pizza")
    if not pizza then return nil end

    if pizza:IsA("BasePart") then
        return pizza.CFrame
    elseif pizza:IsA("Model") then
        local pp = pizza.PrimaryPart or pizza:FindFirstChildWhichIsA("BasePart")
        if pp then return pp.CFrame end
    elseif pizza:IsA("CFrameValue") then
        return pizza.Value
    end
end

RunService.RenderStepped:Connect(function()
    if not getgenv().PizzaSystem.AimbotEnabled then
        restoreRotate()
        currentTarget, isLockedOn = nil, false
        return
    end

    if not isEliot() then
        restoreRotate()
        currentTarget, isLockedOn = nil, false
        return
    end

    local hum = getMyHumanoid()
    if not hum then return end
    local root = Logic.GetHRP()
    if not root then return end

    local attack = isPlayingPizzaAttack()

    if attack and not isLockedOn then
        currentTarget = getWeakestTarget()
        isLockedOn = currentTarget ~= nil
    end

    if isLockedOn and currentTarget then
        local h = currentTarget:FindFirstChildWhichIsA("Humanoid")
        local hrp = Logic.GetHRP(currentTarget)
        if not h or h.Health <= 0 or not hrp then
            currentTarget, isLockedOn = nil, false
        end
    end

    if not attack and wasPlayingAnimation then
        currentTarget, isLockedOn = nil, false
        restoreRotate()
    end

    wasPlayingAnimation = attack

    if attack and isLockedOn and currentTarget then
        local hrp = Logic.GetHRP(currentTarget)
        local targetPos = hrp.Position

        if not autoRotateDisabled then
            hum.AutoRotate = false
            autoRotateDisabled = true
        end

        if hrp.Velocity.Magnitude > 2 then
            targetPos += hrp.CFrame.LookVector * 3
        end

        local offset = root.CFrame.RightVector * aimOffset

        root.CFrame = root.CFrame:Lerp(
            CFrame.lookAt(root.Position, Vector3.new(targetPos.X, root.Position.Y, targetPos.Z) + offset),
            0.99
        )
    end
end)

task.spawn(function()
    while task.wait(0.9) do
        if getgenv().PizzaSystem.AutoEatEnabled then
            local hrp = getHRP()
            local pizza = getPizzaCF()
            if pizza and getHP() <= getgenv().PizzaSystem.HPThreshold then
                local old = hrp.CFrame
                hrp.CFrame = pizza * CFrame.new(0,1,0)

                task.wait(0.2)
                hrp.CFrame = old
                task.wait(0.3)
            end
        end
    end
end)



local Logic = _G.LogicManager
local animTrack = nil

getgenv().InvisibleSystem = getgenv().InvisibleSystem or {
    InstantEnabled = false,
    CloneEnabled = false
}

local function getHumanoid()
    local char = Logic.GetCharacter()
    return char:FindFirstChildOfClass("Humanoid"), char
end

local function getAnimator(humanoid)
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator", humanoid)
    end
    return animator
end

local function playInvisibleAnim(humanoid)
    local animator = getAnimator(humanoid)
    if not animTrack or not animTrack.IsPlaying then
        local anim = Instance.new("Animation")
        anim.AnimationId = "rbxassetid://75804462760596"
        animTrack = animator:LoadAnimation(anim)
        animTrack.Looped = true
        animTrack:Play()
        animTrack:AdjustSpeed(0)
    end
end

local function stopInvisibleAnim()
    if animTrack and animTrack.IsPlaying then
        animTrack:Stop()
        animTrack = nil
    end
end

local function isSurvivorModel(char)
    return char and Logic.IsSurvivor(char)
end

task.spawn(function()
    while task.wait(0.4) do
        local humanoid, char = getHumanoid()
        if not humanoid or not char then
            stopInvisibleAnim()
        else
            if getgenv().InvisibleSystem.InstantEnabled and isSurvivorModel(char) then
                playInvisibleAnim(humanoid)
            elseif getgenv().InvisibleSystem.CloneEnabled then
                local torso = char:FindFirstChild("Torso") or char:FindFirstChild("UpperTorso")
                local root = Logic.GetHRP(char)
                if torso and torso.Transparency ~= 0 then
                    playInvisibleAnim(humanoid)
                    if root then root.Transparency = 0.4 end
                else
                    stopInvisibleAnim()
                    if root then root.Transparency = 1 end
                end
            else
                stopInvisibleAnim()
                local root = Logic.GetHRP(char)
                if root then root.Transparency = 1 end
            end
        end
    end
end)

Logic.Players.LocalPlayer.CharacterAdded:Connect(function(char)
    task.wait(1)
    local humanoid = char:WaitForChild("Humanoid")
    if getgenv().InvisibleSystem.InstantEnabled and isSurvivorModel(char) then
        playInvisibleAnim(humanoid)
    elseif getgenv().InvisibleSystem.CloneEnabled then
        local root = Logic.GetHRP(char)
        if root then root.Transparency = 0.4 end
        playInvisibleAnim(humanoid)
    end
end)





local RunService = game:GetService("RunService")
local Logic = _G.LogicManager

getgenv().AutoBackstab = getgenv().AutoBackstab or {}

local CFG = getgenv().AutoBackstab
CFG.Enabled = CFG.Enabled or false
CFG.Mode = CFG.Mode or "AI Aimbot"
CFG.Radius = CFG.Radius or 18
CFG.Cooldown = CFG.Cooldown or false
CFG.LastTarget = CFG.LastTarget or nil

local ANIM_IDS = {
    "115194624791339",
    "86545133269813",
    "89448354637442",
    "77119710693654",
    "107640065977686",
    "112902284724598",
}

local daggerButton, daggerRemote, daggerConnections = nil, nil, {}

local function initDaggerButton()
    local gui = Logic.PlayerGui
    if not gui then return end
    local mainUI = gui:FindFirstChild("MainUI")
    local container = mainUI and mainUI:FindFirstChild("AbilityContainer")
    daggerButton = container and container:FindFirstChild("Dagger")
    if daggerButton and daggerButton:IsA("ImageButton") then
        daggerConnections = getconnections(daggerButton.MouseButton1Click)
        for _, conn in ipairs(daggerConnections) do
            local f = conn.Function
            if f and islclosure(f) then
                for _, v in pairs(getupvalues(f)) do
                    if typeof(v) == "Instance" and v:IsA("RemoteEvent") then
                        daggerRemote = v
                        return
                    end
                end
            end
        end
    end
end

initDaggerButton()
Logic.LP.CharacterAdded:Connect(function()
    task.wait(0.5)
    initDaggerButton()
end)

local function useDagger()
    if daggerRemote then
        pcall(function()
            daggerRemote:FireServer(true)
            task.delay(0.05, function()
                daggerRemote:FireServer(false)
            end)
        end)
    elseif daggerButton then
        for _, conn in ipairs(daggerConnections) do
            pcall(function() conn:Fire() end)
        end
        pcall(function() daggerButton:Activate() end)
    end
end

-- COMMON FUNCTIONS
local function getCharacter()
    local ch = Logic.GetCharacter()
    local hrp = Logic.GetHRP(ch)
    local humanoid = ch and ch:FindFirstChildOfClass("Humanoid")
    return ch, humanoid, hrp
end

local function isPlayingTargetAnimation(humanoid)
    if not humanoid then return false end
    for _, t in ipairs(humanoid:GetPlayingAnimationTracks()) do
        local animId = tostring(t.Animation.AnimationId or "")
        for _, id in ipairs(ANIM_IDS) do
            if animId:find(id, 1, true) then
                return true
            end
        end
    end
    return false
end

local function teleportBehind(targetHRP, myHRP)
    local look = targetHRP.CFrame.LookVector
    local dest = targetHRP.Position - look * 2
    myHRP.CFrame = CFrame.new(dest, dest + look)
end

local function isBehindTarget(targetHRP, myHRP)
    local look = targetHRP.CFrame.LookVector
    local dir = (myHRP.Position - targetHRP.Position).Unit
    return look:Dot(dir) < -0.5
end

local function getNearbyKillers(position)
    local list = {}
    for _, plr in ipairs(Logic.Players:GetPlayers()) do
        if plr ~= Logic.LP and plr.Character then
            local hrp = Logic.GetHRP(plr.Character)
            if hrp then
                local dist = (hrp.Position - position).Magnitude
                if dist <= CFG.Radius then
                    table.insert(list, {model = plr.Character, hrp = hrp, dist = dist})
                end
            end
        end
    end
    return list
end

local function getNearbyAIKillers(hrp)
    local list = {}
    local killersFolder = Logic.Workspace.Players.Killers
    for _, killer in ipairs(killersFolder:GetChildren()) do
        local kHRP = Logic.GetHRP(killer)
        if kHRP then
            local dist = (kHRP.Position - hrp.Position).Magnitude
            if dist <= CFG.Radius then
                table.insert(list, {model = killer, hrp = kHRP, dist = dist})
            end
        end
    end
    return list
end

RunService.Heartbeat:Connect(function()
    if not CFG.Enabled or CFG.Cooldown then return end

    local char, humanoid, myHRP = getCharacter()
    if not (char and humanoid and myHRP) then return end
    if char.Name ~= "TwoTime" then return end

    if CFG.Mode == "Player Aimbot" then
        if isPlayingTargetAnimation(humanoid) then
            local killers = getNearbyKillers(myHRP.Position)
            if #killers > 0 then
                table.sort(killers, function(a,b) return a.dist < b.dist end)
                local target = killers[1]

                CFG.Cooldown = true
                local start = tick()

                local conn
                conn = RunService.Heartbeat:Connect(function()
                    if tick() - start >= 0.7 then
                        conn:Disconnect()
                        task.delay(1, function() CFG.Cooldown = false end)
                        return
                    end

                    teleportBehind(target.hrp, myHRP)
                    useDagger()
                end)
            end
        end

    else
        local killers = getNearbyAIKillers(myHRP)
        if #killers > 0 then
            table.sort(killers, function(a,b) return a.dist < b.dist end)
            local target = killers[1]

            if target.model ~= CFG.LastTarget and isBehindTarget(target.hrp, myHRP) then
                CFG.Cooldown = true
                CFG.LastTarget = target.model
                local start = tick()

                local conn
                conn = RunService.Heartbeat:Connect(function()
                    if tick() - start >= 0.7 then
                        conn:Disconnect()
                        task.delay(10, function()
                            CFG.Cooldown = false
                            CFG.LastTarget = nil
                        end)
                        return
                    end

                    teleportBehind(target.hrp, myHRP)
                    useDagger()
                end)
            end
        end
    end
end)

_G.AutoBackstabLogic = {
    SetEnabled = function(v) CFG.Enabled = v end,
    SetMode = function(v) CFG.Mode = v end,
    SetRadius = function(v) CFG.Radius = v end,
}



local RunService = game:GetService("RunService")
local Logic = _G.LogicManager
local Players = Logic.Players
local LocalPlayer = Logic.LP

local CFG = getgenv().VoidRushControl or {}
CFG.Enabled = CFG.Enabled or false

local DASH_SPEED = 80
local ATTACK_RANGE = 6
local ATTACK_INTERVAL = 0.2

local survivorsFolder = Logic.survivorsFolder

local Humanoid, RootPart
local lastState = nil
local overrideConn = nil
local attackLoop = nil

local function isPriorityTarget(p)
    if not p or not p.Character then return false end
    return survivorsFolder:FindFirstChild(p.Name) ~= nil
end

local function setupCharacter(char)
    Humanoid = char:WaitForChild("Humanoid")
    RootPart = char:WaitForChild("HumanoidRootPart")

    Humanoid.Died:Connect(function()
        if CFG.Enabled then
            if overrideConn then overrideConn:Disconnect() end
        end
    end)
end

if LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
LocalPlayer.CharacterAdded:Connect(setupCharacter)

local function validTarget(p)
    if p == LocalPlayer then return false end
    local ch = p.Character
    if not ch then return false end
    local hrp = Logic.GetHRP(ch)
    local hum = ch:FindFirstChildOfClass("Humanoid")
    return hrp and hum and hum.Health > 0
end

-- GET CLOSEST TARGET (PRIORITY â†’ ANY)
local function getClosestTarget()
    if not RootPart then return end

    local bestWeak, weakDist = nil, math.huge
    local bestAll, allDist = nil, math.huge

    for _, plr in ipairs(Players:GetPlayers()) do
        if validTarget(plr) then
            local hrp = Logic.GetHRP(plr.Character)
            if hrp then
                local d = (hrp.Position - RootPart.Position).Magnitude

                if isPriorityTarget(plr) and d < weakDist then
                    weakDist = d
                    bestWeak = plr
                end

                if d < allDist then
                    allDist = d
                    bestAll = plr
                end
            end
        end
    end

    return bestWeak or bestAll, (bestWeak and weakDist) or allDist
end

local function attemptAttack()
    local char = LocalPlayer.Character
    if not char then return end
    local tool = char:FindFirstChildOfClass("Tool")
    if tool then pcall(function() tool:Activate() end) end
end

local function startOverride()
    if overrideConn or not Humanoid or not RootPart then return end

    overrideConn = RunService.RenderStepped:Connect(function()
        if not CFG.Enabled or not Humanoid or Humanoid.Health <= 0 then return end

        local target, dist = getClosestTarget()
        if target and target.Character then
            local hrp = Logic.GetHRP(target.Character)
            if not hrp then return end

            local dir = hrp.Position - RootPart.Position
            local flat = Vector3.new(dir.X, 0, dir.Z)

            if flat.Magnitude > 0.1 then
                RootPart.CFrame = CFrame.new(
                    RootPart.Position,
                    Vector3.new(hrp.Position.X, RootPart.Position.Y, hrp.Position.Z)
                )
                RootPart.AssemblyLinearVelocity = flat.Unit * DASH_SPEED
            else
                RootPart.AssemblyLinearVelocity = Vector3.zero
            end
        else
            RootPart.AssemblyLinearVelocity = Vector3.zero
        end
    end)

    attackLoop = task.spawn(function()
        while CFG.Enabled do
            local target, dist = getClosestTarget()
            if target and dist <= ATTACK_RANGE then
                attemptAttack()
            end
            task.wait(ATTACK_INTERVAL)
        end
    end)
end

local function stopOverride()
    if overrideConn then overrideConn:Disconnect() end
    overrideConn = nil

    if RootPart then
        RootPart.AssemblyLinearVelocity = Vector3.zero
    end
end

RunService.RenderStepped:Connect(function()
    if not CFG.Enabled or not Humanoid then return end

    local state = Humanoid.Parent and Humanoid.Parent:GetAttribute("VoidRushState")
    if state ~= lastState then
        lastState = state

        if state == "Dashing" then
            startOverride()
        else
            stopOverride()
        end
    end
end)

_G.VoidRushLogic = {
    SetEnabled = function(v)
        CFG.Enabled = v
        if not v then stopOverride() end
    end
}



local MAX_WAIT = 10
local waited = 0
while not _G.LogicManager and waited < MAX_WAIT do
    waited = waited + 0.1
    task.wait(0.1)
end
local Logic = _G.LogicManager
if not Logic then
    warn("[AimbotLogic] _G.LogicManager not found after wait; will try to use globals where possible.")
    Logic = {
        Players = game:GetService("Players"),
        ReplicatedStorage = game:GetService("ReplicatedStorage"),
        Workspace = game:GetService("Workspace"),
        LP = game:GetService("Players").LocalPlayer,
        PlayerGui = nil,
        survivorsFolder = game:GetService("Workspace"):WaitForChild("Players"):WaitForChild("Survivors")
    }
end

local RunService = game:GetService("RunService")
local Stats = game:GetService("Stats")
local ReplicatedStorage = Logic.ReplicatedStorage or game:GetService("ReplicatedStorage")
local Players = Logic.Players
local LocalPlayer = Logic.LP

local cfg = {
    active = false,
    useOffset = true,
    predictionMode = "Speed",
    aimMode = "Normal",
    aimDuration = 1.7,
    fasterDuration = 1.5,
    spinDuration = 0.5,
    aimTargets = {"Slasher", "c00lkidd", "JohnDoe", "1x1x1x1", "Noli", "Guest 666", "Sixer"},

    autoCoinflip = false,
    coinflipTargetCharge = 3,
    coinflipCooldown = 0.15,
    lastCoinflipTime = 0,

    blockCoinflipWhenClose = true,
    coinflipBlockDist = 50,
}

local Humanoid, HRP = nil, nil
local originalWS, originalJP, originalAutoRotate = nil, nil, nil
local aiming = false
local prevFlintVisibleAim = false
local lastTriggerTime = 0

local RemoteEvent
pcall(function()
    RemoteEvent = ReplicatedStorage:WaitForChild("Modules"):WaitForChild("Network"):WaitForChild("RemoteEvent")
end)

local function setupCharacter(char)
    if not char then return end
    Humanoid = char:WaitForChild("Humanoid")
    HRP = char:WaitForChild("HumanoidRootPart")
    Humanoid.Died:Connect(function()
        aiming = false
        prevFlintVisibleAim = false
        originalWS, originalJP, originalAutoRotate = nil, nil, nil
    end)
end

if LocalPlayer and LocalPlayer.Character then setupCharacter(LocalPlayer.Character) end
if LocalPlayer then LocalPlayer.CharacterAdded:Connect(setupCharacter) end

local function getValidTarget()
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer and plr.Character then
            local char = plr.Character
            local hrp = char:FindFirstChild("HumanoidRootPart")
            if hrp then
                for _, targetName in ipairs(cfg.aimTargets) do
                    if char.Name:lower():find(targetName:lower()) then
                        return hrp
                    end
                end
            end
        end
    end
    return nil
end

local function getPingSeconds()
    local ok, pingStat = pcall(function() return Stats.Network.ServerStatsItem["Data Ping"] end)
    if ok and pingStat then return pingStat:GetValue() / 1000 end
    return 0.1
end

local function isFlintlockVisible()
    if not (LocalPlayer and LocalPlayer.Character) then return false end
    local flint = LocalPlayer.Character:FindFirstChild("Flintlock", true)
    if not flint then return false end
    if not (flint:IsA("BasePart") or flint:IsA("MeshPart") or flint:IsA("UnionOperation")) then
        flint = flint:FindFirstChildWhichIsA("BasePart", true)
        if not flint then return false end
    end
    return flint.Transparency < 1
end

local movementThreshold = 0.5
local function getPredictedAimPosPing(targetHRP)
    local ping = getPingSeconds()
    local velocity = targetHRP.Velocity
    if velocity.Magnitude <= movementThreshold then return targetHRP.Position end
    return targetHRP.Position + (velocity * ping)
end

local function getPredictedAimPosInfrontHRPPing(targetHRP)
    local ping = getPingSeconds()
    local studs = ping * 60
    if targetHRP.Velocity.Magnitude <= movementThreshold then return targetHRP.Position end
    return targetHRP.Position + (targetHRP.CFrame.LookVector * studs)
end

local function computeAimPos(targetHRP)
    if cfg.predictionMode == "Ping" then
        return getPredictedAimPosPing(targetHRP)
    elseif cfg.predictionMode == "front" then
        return targetHRP.Position + targetHRP.CFrame.LookVector * 4
    elseif cfg.predictionMode == "No Lag" then
        return getPredictedAimPosInfrontHRPPing(targetHRP)
    else
        local velocity = targetHRP.Velocity
        if velocity.Magnitude > 0.1 then
            if cfg.useOffset and HRP then
                local ok, toTarget = pcall(function() return (targetHRP.Position - HRP.Position).Unit end)
                if not ok then return targetHRP.Position end
                local moveDir = velocity.Unit
                local dot = toTarget:Dot(moveDir)
                if math.abs(dot) < 0.85 then
                    return targetHRP.Position + velocity * (4 / 60)
                else
                    return targetHRP.Position
                end
            else
                return targetHRP.Position
            end
        else
            return targetHRP.Position
        end
    end
end

local function safeSetCFrame(newCF)
    if typeof(newCF) == "CFrame" and tostring(newCF) ~= "nan" and HRP then
        HRP.CFrame = newCF
    end
end

local function faceInstant(toPos)
    if not HRP or not toPos then return end
    local fromPos = HRP.Position
    if (toPos - fromPos).Magnitude < 0.01 then return end
    local lookAt = Vector3.new(toPos.X, fromPos.Y, toPos.Z)
    local targetCF = CFrame.new(fromPos, lookAt)
    safeSetCFrame(HRP.CFrame:Lerp(targetCF, 0.99))
end

local function getAbilityContainer()
    local ok, container = pcall(function()
        local gui = LocalPlayer:FindFirstChild("PlayerGui")
        if not gui then return nil end
        local mainUI = gui:FindFirstChild("MainUI")
        if not mainUI then return nil end
        return mainUI:FindFirstChild("AbilityContainer")
    end)
    if ok then return container end
    return nil
end

local function tryActivateButton(button)
    if not button then return false end
    pcall(function() if button.Activate then button:Activate() end end)
    local ok, conns = pcall(function()
        if type(getconnections) == "function" and button.MouseButton1Click then
            return getconnections(button.MouseButton1Click)
        end
        return nil
    end)
    if ok and conns then
        for _, conn in ipairs(conns) do
            pcall(function()
                if conn.Function then conn.Function()
                elseif conn.func then conn.func()
                elseif conn.Fire then conn.Fire() end
            end)
        end
    end
    pcall(function() if button.Activated then button.Activated:Fire() end end)
    pcall(function() if button.MouseButton1Click then button.MouseButton1Click:Fire() end end)
    return true
end

local function findAbilityButtonByName(name)
    local container = getAbilityContainer()
    if not container then return nil end
    local btn = container:FindFirstChild(name)
    if btn then return btn end
    local lname = name:lower()
    for _, child in ipairs(container:GetChildren()) do
        if child.Name and child.Name:lower():find(lname) then return child end
        local found = child:FindFirstChildWhichIsA("ImageButton") or child:FindFirstChildWhichIsA("TextButton")
        if found and found.Name and found.Name:lower():find(lname) then
            return found
        end
    end
    return nil
end

local function clickCoinflipButton()
    local tryNames = {"CoinFlip", "Coin", "Reroll"}
    for _, n in ipairs(tryNames) do
        local b = findAbilityButtonByName(n)
        if b then
            if tryActivateButton(b) then return true end
        end
    end
    return false
end

local function findRerollContainer()
    local container = getAbilityContainer()
    if not container then return nil end
    local reroll = container:FindFirstChild("Reroll") or container:FindFirstChild("RerollAbility") or nil
    if reroll then return reroll end
    for _, child in ipairs(container:GetChildren()) do
        for _, obj in ipairs(child:GetDescendants()) do
            if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.Text and tostring(obj.Text):match("%d") then
                return child
            end
        end
    end
    return nil
end

local function getNearbyMaxNumber()
    local reroll = findRerollContainer()
    if not reroll then return nil end
    local maxNum = nil
    for _, obj in ipairs(reroll:GetDescendants()) do
        if (obj:IsA("TextLabel") or obj:IsA("TextButton") or obj:IsA("TextBox")) and obj.Text then
            for num in tostring(obj.Text):gmatch("%d+") do
                local n = tonumber(num)
                if n then
                    if not maxNum or n > maxNum then maxNum = n end
                end
            end
        end
    end
    return maxNum
end

RunService.RenderStepped:Connect(function()
    if cfg.active and Humanoid and HRP then
        local isVisible = isFlintlockVisible()
        if isVisible and not prevFlintVisibleAim and not aiming then
            lastTriggerTime = tick()
            aiming = true
        end
        prevFlintVisibleAim = isVisible

        if aiming then
            local elapsed = tick() - lastTriggerTime

            if cfg.aimMode == "Reflex" then
                if elapsed <= cfg.spinDuration then
                    local spinProgress = elapsed / cfg.spinDuration
                    local spinAngle = math.rad(360 * spinProgress)
                    safeSetCFrame(CFrame.new(HRP.Position) * CFrame.Angles(0, spinAngle, 0))
                elseif elapsed <= cfg.spinDuration + 0.7 then
                    if not originalWS then
                        originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                    end
                    Humanoid.AutoRotate = false
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    local targetHRP = getValidTarget()
                    if targetHRP then
                        faceInstant(computeAimPos(targetHRP))
                    end
                else
                    aiming = false
                    if originalWS then
                        Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate =
                            originalWS, originalJP, originalAutoRotate
                        originalWS, originalJP, originalAutoRotate = nil, nil, nil
                    end
                end
            else
                local duration = (cfg.aimMode == "Faster") and cfg.fasterDuration or cfg.aimDuration
                if elapsed <= duration then
                    if not originalWS then
                        originalWS, originalJP, originalAutoRotate = Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate
                    end
                    Humanoid.AutoRotate = false
                    HRP.AssemblyAngularVelocity = Vector3.zero
                    local targetHRP = getValidTarget()
                    if targetHRP then
                        faceInstant(computeAimPos(targetHRP))
                    end
                else
                    aiming = false
                    if originalWS then
                        Humanoid.WalkSpeed, Humanoid.JumpPower, Humanoid.AutoRotate =
                            originalWS, originalJP, originalAutoRotate
                        originalWS, originalJP, originalAutoRotate = nil, nil, nil
                    end
                end
            end
        end
    end

    if cfg.autoCoinflip then
        local tooClose = false
        if cfg.blockCoinflipWhenClose then
            local targetHRP = getValidTarget()
            if targetHRP and HRP then
                if (targetHRP.Position - HRP.Position).Magnitude <= cfg.coinflipBlockDist then
                    tooClose = true
                end
            end
        end

        if not tooClose then
            local maxNum = getNearbyMaxNumber()
            if not maxNum or maxNum < cfg.coinflipTargetCharge then
                if tick() - cfg.lastCoinflipTime >= cfg.coinflipCooldown then
                    cfg.lastCoinflipTime = tick()
                    local ok = clickCoinflipButton()
                    if not ok and RemoteEvent then
                        pcall(function()
                            RemoteEvent:FireServer("UseActorAbility", "CoinFlip")
                        end)
                    end
                end
            end
        end
    end
end)

local AimbotManager = {}

function AimbotManager.SetActive(v) cfg.active = not not v end
function AimbotManager.GetActive() return cfg.active end

function AimbotManager.SetUseOffset(v) cfg.useOffset = not not v end
function AimbotManager.GetUseOffset() return cfg.useOffset end

function AimbotManager.SetPredictionMode(v) if type(v)=="string" then cfg.predictionMode = v end end
function AimbotManager.GetPredictionMode() return cfg.predictionMode end

function AimbotManager.SetAimMode(v)
    if type(v) == "string" then cfg.aimMode = v end
end
function AimbotManager.GetAimMode() return cfg.aimMode end

function AimbotManager.SetCoinflipEnabled(v) cfg.autoCoinflip = not not v end
function AimbotManager.SetCoinflipTargetScore(n) n = tonumber(n) if n then cfg.coinflipTargetCharge = n end end
function AimbotManager.SetCoinflipCooldown(n) n = tonumber(n) if n then cfg.coinflipCooldown = n end end
function AimbotManager.SetCoinflipDistance(n) n = tonumber(n) if n then cfg.coinflipBlockDist = n end end
function AimbotManager.SetBlockCoinflipWhenClose(v) cfg.blockCoinflipWhenClose = not not v end

function AimbotManager.GetConfig() return cfg end

_G.AimbotManager = AimbotManager
